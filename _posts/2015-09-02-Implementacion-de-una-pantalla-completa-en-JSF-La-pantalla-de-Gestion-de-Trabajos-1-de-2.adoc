= Implementación de una pantalla completa en JSF: La pantalla de Gestión de Trabajos (1 de 2).
La metaweb
:hp-tags: JSF, JavaServer Faces, Primefaces, CRUD, EJB, Hibernate, backing bean
:published_at: 2015-09-02

+++<style>span.boton {color:#A80000;border-style: solid;border-width: 2px;padding-top: 0em;padding-right: .8em;padding-bottom: 0em;padding-left: .8em;-webkit-border-radius: 4px;-moz-border-radius: 4px;border-radius: 4px;}</style>+++

== El concepto de CRUD.

En este post veremos los aspectos generales de la implementación del caso de uso del mantenimiento de la entidad Trabajo. https://github.com/lametaweb/jdrone/releases/tag/1.1.0[Aquí] podéis bajaros la release 1.1.0 del proyecto, que se corresponde con el código de este Post y del siguiente, que tratará aspectos más específicos de la implementación.

El mantenimiento o gestión de una entidad, conocido en inglés como CRUD (create, read, update and delete) tiene por objeto permitir el tratamiento de la información de la entidad en un sistema. En general un CRUD se implementa en tres pantallas: La pantalla inicial o de maestro, que se presenta inicialmente, contiene el listado de entidades a gestionar, y da acceso a la operaciones, la pantalla de consulta de detalle, que muestra una vista completa de la entidad, y por último la pantalla de creación / edición del detalle, que permite dar de alta o modificar una entidad concreta.

En la pantalla de maestro tenemos una tabla donde cada fila corresponde a una entidad y contiene una serie de campos que la identifican y otros adicionales que puedan ser de utilidad a la hora de ordenar o filtrar. En cada fila, a la derecha, tendremos tres botones, correspondientes a las operaciones RUD (read, update and delete), y fuera del listado situaremos un botón adicional para la operación C (create). Finalmente necesitaremos un botón, también fuera del listado, para salir de la pantalla cuando queramos finalizar la gestión de Trabajos. Esta pantalla es común a todos los CRUDs. A continuación se muestra el aspecto que debería tener esta pantalla:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig020.png[]

La pantalla de consulta de detalle simplemente amplía la información mostrada en cada fila y es común mostrarla en una ventana emergente. Veremos que esto es muy sencillo cuando utilizamos la librería Primefaces.

NOTE: Si queréis ver o comparar la popularidad de alguna librería o tecnología usad _Google Trends_. Tendréis que añadir los términos que identifiquen a cada tecnología cuidando de que el término no recoja resultados no deseados. Por ejemplo si queréis ver la tendencia del framework _ionic_ para aplicaciones híbridas escribid "ionic framework" y no "ionic" a secas. La URL es https://www.google.es/trends[ésta].

La pantalla de creación / edición de detalle es la más compleja, y la más interesante, y es diferente en cada CRUD ya que dependerá de las relaciones que existan entre la entidad gestionada y el resto. Recordemos nuestro diagrama de clases:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig045.png[]

Observamos una relación muchos a uno con la entidad _Drone_ y otra de composición con la entidad _PuntoRuta_. Ambas relaciones tendrán su correspondiente efecto en la pantalla de detalle. La relación con _Drone_ se traducirá en un componente _selectOneMenu_ y la relación con los _PuntoRuta_ en un componente _dataTable_ que deberá tener asociado una serie de componentes adicionales que permitan gestionar la relación de composición, es decir, añadir, quitar o editar puntos de ruta del Trabajo. El diseño de la pantalla de detalle sería algo así:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig025.png[]

Es importante señalar que no existe una solución única a la hora de implementar un caso de uso, ni para las páginas, ni los backing beans. Como regla general intentaremos siempre conseguir un resultado que proporcione la mejor experiencia de usuario al tiempo que cumpla con todos los requisitos funcionales acordados con el cliente. Respecto de esto último el cliente podría por ejemplo pedirnos que en la página de detalle dispusieramos de ventanas emergentes de asistencia: Ventana calculadora de distancias entre dos puntos, ángulos entre trayectorias, conversión de unidades, etc.

En un CRUD por tanto existirán tareas de desarrollo generales y comunes a cualquier mantenimiento, y tareas especificas, localizadas sobre todo en la pantalla de detalle, que son las que van a plantearnos los mayores retos a la hora de conseguir la funcionalidad deseada.

== Configuraciones en el entorno de trabajo.

Hacemos aquí un paréntesis para actualizar el entorno de trabajo. Queremos que nuestra productividad sea máxima y para ello decidimos instalar la librería de componentes Primefaces así como la última versión disponible de JSF.

Añadir Primefaces al proyecto es sencillo, basta con añadir la dependencia correspondiente al proyecto:

[source,xhtml,indent=0]
----
		<dependency>  
		    <groupId>org.primefaces</groupId>  
		    <artifactId>primefaces</artifactId>  
		    <version>5.2</version>  
		</dependency>
----

Sin embargo, subir JSF de la versión 2.1 a la 2.2 no es tan simple. El proceso para añadir un nuevo módulo con JSF 2.2 en nuestro servidor JBoss EAP 6.3 no es directo. He intentado seguir el procedimiento existente en internet sin resultados. En resumen el proceso pasa por bajar una aplicación Maven desde Github que genera un fichero CLI que realiza el deploy de los tres slots para los tres módulos que se ven afectados por la actualización. Sin embargo uno de los slots da problemas ya que parece que el script está actualizado para operar con las versiones iniciales del servidor Wildfly y no con JBoss EAP.

A la vista de lo anterior se optará por instalar el nuevo servidor Wildfly en su última versión, la 9.0.1, y así tener disponible además una plataforma Java EE 7 completa. Lo primero será descargar el fichero de instalación del servidor desde http://wildfly.org/downloads/[aquí]. Tenéis que elegir la primera de las opciones en la lista, etiquetada con Java EE7 Full & Web Distribution. En el momento de redactar este Post ya estaba disponible Wilfly 10, así que podéis instalarlo en vez de el 9. Entiendo que no debe afectar en cuento a instalación e integración con Eclipse.

NOTE: Descargaos también los _Quickstarts_ porque os van a venir muy bien como material de consulta en las etapas iniciales de la implementanción de un nuevo proyecto sea cual sea su naturaleza.

Después de instalar el nuevo servidor y antes de iniciarlo debemos añadir un usuario. Para ello tenemos que ejecutar el archivo por lotes _bin\add-user.bat_.

Una vez instalado WildFly lo añadimos a Eclipse como nueva unidad de ejecución. La versión de las JBoss Tools sólo ofrecía un conector para la versión 8 pero después de las pruebas de arranque y parada se comprueba no hay problemas con esto.

NOTE: Si queréis practicar con el programa de control de versiones Git podéis hacer un fork de la aplicación jdrone en vuestra cuenta de GitHub y a continuación crear un repo local Git que os permita realizar pruebas sobre la aplicación en vuestra máquina.

Bien, después de actualizar a Wilfly 9 ó 10 ¿Qué cambios tenemos que hacer en nuestro proyecto? En primer lugar tendremos que adaptar las dependencias Maven a las del nuevo servidor, un proceso sin demasiada complicación. Podéis consultar el contenido del fichero _pom.xml_ en GitHub.

Se ha refactorizado además el ciclo de construcción de modo que ahora existe un profile _despliegue-recursos_ que se debe ejecutar la primera vez que despleguemos la aplicación, o bien cuando los recursos hayan sido eliminados del mismo por cualquier motivo. Tenéis también que crear un nueva configuración de ejecución: Botón derecho sobre proyecto y _Run As_ > _Run Configurations..._  Botón derecho sobre _Maven build_ > _New_.  En la entrada _Goals_ escribid `clean install -Pdespliegue-recursos` y dad un nombre al nuevo perfil.

En segundo lugar, como vamos a subir desde JSF 2.1 a 2.2 tenemos que actualizar los espacios de nombres en el nodo raiz del fichero _faces-config.xml_. Además tendremos que actualizar la faceta JavaServer Faces del proyecto. La desmarcamos, esperamos a que se desinstale y la volvemos a marcar. Al añadir de nuevo la opción _JSF Implementation Library_ dejadla así _Type > Disable Library Configuration_.

Para comprobar que JSF 2.2 funciona correctamente modificamos nuestra página _index.xhtml_ para adaptarla a HTML5 y JSF 2.2, añadiendo además una etiqueta nueva en la versión 2.2.

Para la adaptación a HTML 5 actualizamos la página así:

`<!DOCTYPE html>`

Para la adaptación a JSF 2.2 cambiamos los espacios de nombres:

`<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:h="http://xmlns.jcp.org/jsf/html"
	xmlns:f="http://xmlns.jcp.org/jsf/core">`

Finalmente sustituimos:

`<f:event listener="#{disponibilidadBean.listaEstadoDronesPorFecha()}" type="preRenderView" />`

por:

`<f:viewAction action="#{disponibilidadBean.listaEstadoDronesPorFecha()}" onPostback="true"></f:viewAction>`

Además ahora no se admitirán los típicos caracteres de espaciado `\&nbsp;` y tendremos que sustituirlos por el equivalente código unicode `\&#160;`.

La etiqueta `viewAction` es nueva en JSF 2.2. Asocia un evento a una página ofreciendo más flexibilidad que la etiqueta `event` para acciones de precarga de datos para una página. La forma en que se usa en la página de consulta de listado de drones no es la habitual, y por eso es necesario añadir el atributo `onPostback="true"`, sin embargo, a continuación veremos un uso adecuado tanto en la página de maestro como en la de detalle.

Bien, con el diseño inicial de las páginas listo podemos empezar con el desarrollo. Aquí no lo veremos paso a paso como en Posts anteriores sino que, sobre el código del proyecto que habéis bajado de GitHub, intentaremos entender cómo se desarrolla en JSF. Nos centraremos en la capa de presentación y comentaremos la capa de servicio al final ya que en un CRUD no tiene demasiado interés por su simplicidad.

=== La página de maestro: trabajos.xhtml.

Pensemos en la pantalla de maestro y sus distintos elementos. Tenemos un listado con datos de sólo lectura, los botones Borrar icon:trash[], Editar icon:pencil[] y Ver icon:search[] asociados a cada entidad del listado y los botones Salir y Crear a nivel de pantalla:

* El listado de entidades: La página de maestro debe mostrar inicialmente, es decir en la Initial Request, todos los Trabajos. Tenemos que tener los datos disponibles por tanto antes de la fase Render Response. Esto lo conseguimos con la etiqueta viewAction. Esta etiqueta añade un evento al ciclo de vida de JSF de la request Initial Request a la página que la contiene, que es justo lo que necesitamos.

[source,xhtml,indent=0]
----
	<f:metadata>
		<f:viewAction action="#{trabajosBean.actualizaModeloTrabajos()}"></f:viewAction>
	</f:metadata>
----

El método `trabajosBean.actualizaModeloTrabajos()` realiza una llamada a la capa de servicio y actualiza el Modelo en el backing bean de la capa de presentación. Lo siguiente es que la página es renderizada en el servidor en la fase de Render Response. Durante esta fase entran en juego los bindings establecidos en la tabla dataTable, que tiran del Modelo para renderizar cada campo de datos de cada Trabajo. En el siguiente trozo de código aparece el binding para la primera columna de la tabla:

[source,xhtml,indent=0]
----
		<p:dataTable id="tabla" var="trabajo" value="#{trabajosBean.trabajos}">
			<!-- datos -->
		    <p:column headerText="N. Registro">
		        <h:outputText value="#{trabajo.numeroDeRegistro}" />
		    </p:column>
----

* Los botones de acción a nivel de entidad: La página ya ha sido renderizada y se muestra correctamente en nuestro navegador. Si el código de la página es correcto cuando pulsemos alguno de los botones Borrar, Editar o Ver se debe obtener la funcionalidad deseada.

El botón Ver en general se implementa para que navegue a otra página donde se muestra el detalle de la entidad seleccionada, sin embargo aprovechamos las capacidades de Primefaces para mostrar ventanas emergentes y mostramos los datos del Trabajo en un diálogo emergente. El código sería:

[source,xhtml,indent=0]
----
<p:commandButton update=":formulario:trabajoDetail" icon="ui-icon-search" oncomplete="PF('trabajoDialog').show()">
	<f:setPropertyActionListener value="#{trabajo}" target="#{trabajosBean.trabajoSeleccionado}"></f:setPropertyActionListener>
</p:commandButton>
----

La secuencia sería la siguiente: La etiqueta `setPropertyActionListener` actualiza la variable del Modelo `trabajosBean.trabajoSeleccionado` del que tira el cuadro de diálogo. La llamada Ajax actualiza el panel de datos `:formulario:trabajoDetail` y finalmente el diálogo es mostrado con la llamada Javascript `PF('trabajoDialog').show()`. Lo que tenemos es una Postback Request a la propia página.

El botón Editar sí lleva a cabo una navegación. El código es el siguiente:

[source,xhtml,indent=0]
----
		        <p:button outcome="/trabajo" icon="ui-icon-pencil">
		        	<f:param name="idTrabajo" value="#{trabajo.idTrabajo}"></f:param>
		        </p:button>
----

Como vemos lo único que hace es navegar a la página de creación / edición del detalle. Para esto se usa la etiqueta `button`, no la `commandButton`. Es necesario enviar un parámetro en la request que indique el Trabajo que se va a editar. Se lleva a cabo por tanto una Initial Request a la página de detalle.

Por último el botón Borrar genera, al igual que el botón Ver, una Postback Request, que como ya sabemos, inicará un ciclo completo de JSF. Será un ciclo Ajax, que es el comportamiento por defecto para los botones en Primefaces. En la fase Invoke Application de este ciclo se llamará al método de borrado `trabajosBean.eliminar(trabajo)` del backing bean. El código completo es:

[source,xhtml,indent=0]
----
		        <p:commandButton 
			        action="#{trabajosBean.eliminar(trabajo)}"
			        update=":formulario:paneltrabajos"
			        icon="ui-icon-trash">
		        		<p:confirm header="Borrado de trabajo" message="Pulsa Confirmar para confirmar acción" icon="ui-icon-alert" />
		        </p:commandButton>
----

En general para las acciones de borrado, ya sea físico o lógico, es conveniente presentar un cuadro de diálogo de confirmación al usuario. En Primefaces es muy fácil de implementar usando un cuadro de diálogo global.

Bien, nos queda por ver los dos botones a nivel de página `Salir` y `Crear`. Como véis en la figura que muestra el diseño de la página, he colocado estos botones encima del listado de Trabajos, creo que así se mejora la experiencia de usuario ya que los botones siempre van a estar en la misma posición independientemente del número de filas del listado y además se muestran en una posición más accesible, sobre todo en pantallas de tamaño reducido.

El botón Salir simplemente navega a la página de inicio:

[source,xhtml,indent=0]
----
<p:button value="Salir" outcome="/index" />
----

Y el botón `Crear ` es igual de simple, navega a la misma página a la que nos lleva el botón `Editar` pero sin especificar ningún parámetro:

[source,xhtml,indent=0]
----
<p:button value="Crear" outcome="/trabajo" />
----

Y hasta aquí los aspectos más importantes de la página de maestro.

=== La página de detalle: trabajo.xhtml.

Como hemos visto esta pantalla es más compleja que la de maestro y su complejidad dependerá del número y tipo de relaciones de la entidad que queremos gestionar.

Veamos los aspectos generales primero y luego los detalles más destacables. Usaremos la misma página tanto para la edición como para la creación de una entidad Trabajo. Veamos la secuencia de acciones que ocurren cuando navegamos a la página de detalle, tanto en el caso de una edición como en el caso de una creación. Recordemos que lo que tenemos es una Initial Request.

En primer lugar una instancia del backing bean es creada. Justo después se ejecuta el método anotado con @PostConstruct, que crea una instancia  de la entidad gestionada, Trabajo. A continuación se acualiza el modelo con el valor del parámetro `idTrabajo` si existe, y finalmente se ejecuta el método especificado en la etiqueta `viewParam`:

[source,xhtml,indent=0]
----
	<f:metadata>
		<f:viewParam name="idTrabajo" value="#{trabajoBean.trabajo.idTrabajo}"></f:viewParam>
		<f:viewAction action="#{trabajoBean.actualizaModeloTrabajo()}"></f:viewAction>
	</f:metadata>
----

Si el usuario navegó para una creación, el parámetro es nulo y la entidad `trabajo` del modelo no varía. En cambio en una edición el campo `idTrabajo` se actualiza con el valor del ID seleccionado en la pantalla de maestro.

En el método `actualizaModeloTrabajo()` comprobamos el valor del ID y si no es nulo actualizamos el Modelo para que en la fase Render Response se muestren los datos del trabajo que el usuario desea editar.

Bien, como antes, tenemos nuestra página lista para la creación o la edición. En este post vamos a ver sólo los dos botones a nivel de página: Salir y Aceptar.

El botón Salir es simple, se trata de un botón de cancelación:

`<p:button value="Salir" outcome="/trabajos.xhtml"/>`

Ejecuta una navegación con una petición GET a la página de maestro. Esta simplicidad es posible porque en este caso la cancelación de la sesión de edición de un Trabajo no requiere ninguna acción adicional. Si precisaramos realizar alguna acción, por ejemplo para liberar recursos a nivel del ámbito de sesión o de aplicación, o para realizar una escritura en base de datos para grabar la fecha y hora de la cancelación, entonces no nos valdría con lo anterior y tendríamos que elegir entre dos soluciones, siempre usando un componente de tipo "command":

* Configurar el botón para que se procese sólo a sí mismo en la llamada Ajax. De esta manera el resto del formulario no se vé afectado y conseguimos evitar la ejecución de conversiones y validaciones:

`<p:commandButton value="Salir" process="@this" action="/trabajos.xhtml?faces-redirect=true" />`

* Configurar el botón con el modificador `inmmediate` a true. De esta manera la accion asociada a la cancelación se realiza en la fase de Apply Request Values y luego se salta a la fase de Render Response, ignorando como en el caso anterior conversiones y validaciones:

`<p:commandButton value="Salir" action="/trabajos.xhtml?faces-redirect=true" immediate="true" />`

Es importante tener claro que durante una sesión de edición de una entidad tenemos que guardar los cambios en la correspondiente variable del Modelo en el backing bean, y sólo llamar al método de la capa de Servicio para persistir estos cambios al final de la sesión, cuando el usuario pulsa el botón +++<span class="boton">+++Aceptar+++</span>+++. La variable del backing bean será una entidad _detached_ en el caso de una edición y una entidad _new_ en el caso de una creación. En el método de Servicio   simplemente metemos la entidad en el contexto de persistencia convirtiéndola en _managed_, y finalmente cuando el método finaliza JTA ordena el commit que persiste los cambios.

Veamos por último el botón +++<span class="boton">+++Aceptar+++</span>+++. Su aspecto puede intimidar un poco a primera vista:

[source,xhtml,indent=0]
----
<p:commandButton id="aceptar" value="Aceptar" action="#{trabajoBean.aceptar}" update="@(:input:not(.notsend)) mensajes" process="@(:input:not(.notsend))" oncomplete="ajustaPosicionEtiquetas();" />
----

Bien, primero lo sencillo. Se trata de un botón de comando, y que por lo tanto genera una petición Ajax de tipo Postback de la propia página. Esto dispara en el servidor un ciclo de vida completo de JSF. Se llevarán a cabo las conversiones, validaciones y actualización del Modelo para el subconjunto de valores que nos interesa, a continuación se ejecuta la llamada al método de servicio y finalmente actualizamos la zona adecuada de la página. Finalmente hay un ajuste dinámico de estilo. Veamos más detenidamente cada atributo del componente:

* process y update: El primero determina lo que enviamos y en segundo lo que actualizamos en la llamada Ajax. Lo interesante aquí es que se ha tenido que usar un selector complejo para definir estos conjuntos de elementos. El motivo es que se ha usado un elemento para maquetar la página que englobaba a la entidad Trabajo y también a sus PuntosRuta y como no puedo meter un formulario dentro de otro tanto la entidad padre como las hijas están en el mismo formulario y de ahí que sea necesario filtrar lo que se envía al servidor. Cuando pulse Aceptar sólo deberé enviar al servidor los campos de la entidad Trabajo y no los de los tres campos de introducción de un PuntoRuta. Para esto uso la capacidad de PrimeFaces de usar selectores de jQuery:

`@(:input:not(.notsend))`

Aquí se usa el selector de jQuery para seleccionar todos los elementos de entrada del formulario, y luego se restan los de la clase .notsend. De modo que si damos a los tres campos de entrada de PuntoRuta la clase .notsend evitaremos que estos intervengan en el submit generado al pulsar el botón Aceptar.

* action: Indica la llamada a la capa de Servicio para persistir el Trabajo. Tenemos un mismo método tanto para la creación como para la edición de la entidad. Esto es posible porque en JPA con un merge metemos en el contexto de persistencia tanto una entidad new como una detached, y esto es lo único que tenemos que hacer para que la entidad se persista cuando el método de la capa de Servicio termine y JTA invoque el commit de manera automática.

* oncomplete: Se incluye para llamar a una función JS que restablece el estilo de las etiquetas de campos que ocupan una altura grande, en concreto los campos _Descripción_ y _Puntos de Ruta_. Esto es necesario porque para modificar el estilo de estos elementos fue necesario usar JS al no existir ningún selector adecuado, y cada vez que la pantalla se refrescar hay que reescribir el estilo. Esto es un ejemplo de cómo a veces para conseguir una buena experiencia de usuario es necesario usar técnicas un poco atípicas.

Bien, hasta aquí los aspectos generales de la pantalla de detalle. A continuación y para concluir con este post veamos qués una plantilla de Facelets y su aplicación a la pantalla de consulta del post anterior.

== Uso de plantillas: Una plantilla adaptativa para jDrone

Una interfaz adaptativa, en inglés responsive, se hace necesaria casi en cualquier proyecto hoy en día dada la variabilidad del tamaño de pantalla de los distintos dispositivos: Laptops, tablets, phablets, moviles, es muy variado. En una aplicación JSF una buena alternativa es usar el componente Grid CSS de Primefaces para realizar la maquetación de las áreas principales y comunes de las páginas del proyecto: Cabecera, menú, barra de navegación, sides, zona central principal, pie. Así mismo es interesante el uso de la clase CSS `ui-fluid` que va a darnos una interfaz fluida cálculando la posición y tamaño de cada componente dependiente del dispositivo.

Grid CSS no es más que una librería de estilos, similar a Bootstrap, pero compatible con JSF y Primefaces. Antes de empezar a implementar lo mejor es tomar lápiz y papel o una herramienta similar a Inkscape y dibujar un boceto del layout de la página completa que queremos y así tener claro los divs que voy a necesitar para crear las áreas de la pantalla.

Una plantilla es otra página JSF que define la estructura y el contenido común de todas las páginas de la aplicación que la usan. El contenido variable se inyectará mediante etiquetas `<ui:insert...>`. Una vez que tenemos lista nuestra plantilla, en la carpeta _/jdrone/src/main/webapp/WEB-INF/plantillas/plantilla.xhtml_ con su hoja de estilos correspondiente podremos crear cada página de la aplicación en base a la plantilla:

[source,xhtml,indent=0]
----
	<ui:composition...>
    	<ui:define name="central">
        	...
        </ui:define>
        <ui:define name="logo">
       		<ui:include... />
        </ui:define>
        ...
    </ui:composition>
----

El contenido de la zona variable _central_ se define en la página en general al principio para mayor claridad dado que aquí el orden no afecta. La zona del logo la hacemos insertable aunque en todas las páginas aparecerá como un include, esto nos da la posibilidad de tener páginas especiales que prescindan del logo si por ejemplo necesitamos espacio extra.

Veamos ahora un ejemplo práctico de uso de plantilla, y que mejor manera que adaptando la pantalla de consulta del post anterior, de drones disponibles en una fecha, al nuevo diseño de pantalla. Lo primero que hacemos es mover el contenido desde el fichero `index.xhtml`, que ahora pasará a ser la pantalla inicial de la aplicación, al fichero `consulta-inicial.xhtml`.

Luego tendremos que crear el panel para el logo, podéis ir al código de la aplicación y ver que su raíz es un elemento `<ui:composition... >` ya que irá inyectado en la plantilla, pero sin embargo no contiene elementos `<ui:define...>` ya que no se trata de una página pública que hace uso de la plantilla. He incluido aquí una sencilla animación realizada con la librería JS jQuery para que, si aún no la conocéis, tengáis una primera toma de contacto. Es muy importante conocerla al máximo ya que ahorra mucho tiempo de desarrollo en la parte de cliente. Además que Primefaces esté basado en jQuery es otro motivo más para dedicarle tiempo. Como nuestro proyecto incluye Primemefaces y éste incluye jQuery no tenemos ni debemos de añadir la librería de manera explícita. 

No es habitual, pero si una página de nuestro proyecto no usa ninguna estiqueta de Primefaces entonces tendremos que incluir de manera explícita la librería jQuery embebida en Primefaces añadiendo:

[source,xhtml,indent=0]
----
<h:outputScript library="primefaces" name="jquery/jquery.js" target="head" />
<h:outputScript library="primefaces" name="jquery/jquery-plugins.js" target="head" />
----

Con nuestra página de consulta ya maquetada lo siguiente es añadir un menú de opciones. Optaremos por la clásica barra de menú de las aplicaciones de Escritorio. Como suele ocurrir cuando necesitamos algún elemento para la capa de presentación Primefaces nos da, también en esta ocasión, la solución con el componente `<p:MenuBar...>`. Tened en cuenta que la versión 5.2, abierta a la comunidad y usada en nuestro programa, tiene casi 150 componentes. Usando este componente en un par de minutos dibujamos las opciones y submenús que tengamos previstos para la aplicación. Finalmente, para situar el menú en la página, lo metemos, al igual que el logo, en un panel, y lo situamos en la plantilla añadiendo a la misma un elemento `<ui:insert...>`.

Arrancamos el servidor y ejecutamos nuestro ciclo de construcción para ver el aspecto en pantalla. Personalmente no me convence el aspecto por defecto del menú por lo que acudimos de nuevo a Primefaces y vemos que es muy sencillo dar un aspecto distinto a los componentes simplemente eligiendo otro _Theme_. Además de paso activamos los iconos de FontAwesome añadiendo el correspondiente parámetro en el fichero _web.xml_ y así disponer de una mayor variedad de iconos.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig005.png[]

Para cambiar el _Theme_ tenemos que añadir una dependencia de Maven, elegimos el _Theme bluesky_, más acorde con la Marca de la compañía cliente:

[source,xml,indent=0]
----
  <dependency>
    <groupId>org.primefaces.themes</groupId>
    <artifactId>bluesky</artifactId>
    <version>1.0.10</version>
  </dependency>
----

Y añadir un parámetro en el descriptor de despliegue, _web.xml_:

[source,xml,indent=0]
----
  <context-param>
    <param-name>primefaces.THEME</param-name>
    <param-value>bluesky</param-value>
  </context-param>
----

Guardamos los cambios. Si abrimos el fichero _pom.xml_ observamos que se muestra un error en la dependencia añadida, esto es debido a que esta dependencia no está en el repositorio Central. Tenemos por tanto que añadir el repositorio de Primefaces a nuestra configuración de Maven. Podemos hacerlo directamente desde la sugerencia que nos muestra Eclipse al poner el puntero del ratón sobre el error. Introducid los datos tal y como aparecen en la siguiente figura:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig010.png[]

Pulsamos _OK_ y _Finish_. Para afinar el estilo de la barra de menú aún más podemos modificar el estilo aplicado por el framework a los componentes que forman el menú. En la documentación de Primefaces aparecen estos estilos, pero lo más práctico es ayudarnos de las herramientas de desarrollador de Chrome o Firefox (F12) para localizar fácilmente los estilos aplicados a cada elemento sobre la propia pantalla y editarlos para ver los cambios on the fly.


Para estilizar los menús añadid al principio del fichero _plantilla.css_ lo siguiente: 

[source,css,indent=0]
----
.ui-menubar{
	height: 1.em;	
	padding:0em !important;	
}
.ui-menuitem{
	height: 1.8em;
}
----

Desplegad los cambios en WildFly y comprobad que el nuevo aspecto de la pantalla es similar a éste:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig015.png[]

NOTE: Existe una herramienta muy interesante que evita los redespliegues en el servidor de desarrollo durante la implementación de una aplicación. Se trata de JRebel, http://zeroturnaround.com/software/jrebel/. Es una herramienta de pago pero ofrecen una modalidad gratuita en http://my.jrebel.com[esta dirección].

Para terminar movemos el contenido de index.html a consulta-inicial.xhtml y dejamos index.xhtml con un fondo de pantalla limpio como pantalla inicial de la aplicación, añadiendo una imagen de fondo.

Para el próximo Post voy a preparar una lista en un formato de Preguntas y repuestas, Q&A, para aclarar distintas partes del código de la aplicación jDrone y no dejarnos nada en el tintero. Hasta pronto!