= Implementación de una pantalla completa en JSF: La pantalla de Gestión de Trabajos (1 de 2).
La metaweb
:hp-tags: JSF, JavaServer Faces, Primefaces, CRUD, EJB, Hibernate, backing bean
:published_at: 2015-09-02

=== Introducción

En este post analizaremos los aspectos generales implicados en la implementación de la funcionalidad de gestión / mantenimiento de la entidad Trabajo. Podéis bajaros el código fuente de la release 1.1.0 del proyecto, que corresponde  a este Post y al siguiente en https://github.com/lametaweb/jdrone/releases/tag/1.1.0[esta dirección].

En general un mantenimiento se organiza en tres pantallas: 

. La pantalla inicial o de maestro, que se presenta inicialmente, contiene el listado de entidades, opcionalmente un área para el filtrado del listado, y una serie de componentes de acción que dan acceso a las operaciones de mantenimiento. 

. La pantalla de consulta del detalle, que muestra o da acceso a todos los datos de la entidad concreta seleccionada en la pantalla de maestro. 

. La pantalla de creación / edición del detalle, que permite crear una nueva entidad o bien modificar la entidad concreta seleccionada en la pantalla de maestro.

+++<style>span.boton {color:#A80000;border-style: solid;border-width: 2px;padding-top: 0em;padding-right: .8em;padding-bottom: 0em;padding-left: .8em;-webkit-border-radius: 4px;-moz-border-radius: 4px;border-radius: 4px;}</style>+++

Veamos más en detalle cada una de las pantallas:

En la pantalla de maestro el elemento central es una tabla donde cada fila muestra un subconjunto de los campos de la entidad. Este subconjunto estará formado por un lado por los campos identificativos y por otro por campos adicionales que nos interese añadir para facilitar la ordenación o el filtrado del listado. A la derecha de los campos de datos, en cada fila, añadiremos tres botones para las operaciones de consulta, edición y eliminación de la entidad. Fuera ya del listado situaremos un botón para el acceso a la pantalla de creación de una nueva entidad y otro para salir de la pantalla de maestro cuando queramos finalizar la gestión de Trabajos. Esta pantalla es común a todos los mantenimientos y tiene este aspecto:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig020.png[]

La pantalla de consulta de detalle simplemente amplía la información mostrada en cada fila y es común mostrarla en una ventana emergente. Veremos que esto es muy sencillo cuando utilizamos la librería Primefaces.

NOTE: Si queréis ver o comparar la popularidad de alguna librería o tecnología usad _Google Trends_. Tendréis que añadir los términos que identifiquen a cada tecnología cuidando de que el término no recoja resultados no deseados. Por ejemplo si queréis ver la tendencia del framework _ionic_ para aplicaciones híbridas escribid "ionic framework" y no "ionic" a secas. La URL es https://www.google.es/trends[ésta].

La pantalla de creación / edición de detalle es la más compleja, y la más interesante, y es diferente en cada CRUD ya que dependerá de las relaciones que existan entre la entidad gestionada y el resto. Recordemos nuestro diagrama de clases:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig045.png[]

Observamos una relación muchos a uno con la entidad _Drone_ y otra de composición con la entidad _PuntoRuta_. Ambas relaciones tendrán su correspondiente efecto en la pantalla de detalle. La relación con _Drone_ se traducirá en un componente _selectOneMenu_ y la relación con los _PuntoRuta_ en un componente _dataTable_ que deberá tener asociado una serie de componentes adicionales que permitan gestionar la relación de composición, es decir, añadir, quitar o editar puntos de ruta del Trabajo. El diseño de la pantalla de detalle sería algo así:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig025.png[]

Es importante señalar que no existe una solución única a la hora de implementar un caso de uso, ni para las páginas, ni los backing beans. Como regla general intentaremos siempre conseguir un resultado que proporcione la mejor experiencia de usuario al tiempo que cumpla con todos los requisitos funcionales acordados con el cliente. Respecto de esto último el cliente podría por ejemplo pedirnos que en la página de detalle dispusieramos de ventanas emergentes de asistencia: Ventana calculadora de distancias entre dos puntos, ángulos entre trayectorias, conversión de unidades, etc.

En un CRUD por tanto existirán tareas de desarrollo generales y comunes a cualquier mantenimiento, y tareas especificas, localizadas sobre todo en la pantalla de detalle, que son las que van a plantearnos los mayores retos a la hora de conseguir la funcionalidad deseada.

== Configuraciones en el entorno de trabajo.

Hacemos aquí un paréntesis para actualizar el entorno de trabajo. Queremos que nuestra productividad sea máxima y para ello decidimos instalar la librería de componentes Primefaces así como la última versión disponible de JSF.

Añadir Primefaces al proyecto es sencillo, basta con añadir la dependencia correspondiente al proyecto:

[source,xhtml,indent=0]
----
		<dependency>  
		    <groupId>org.primefaces</groupId>  
		    <artifactId>primefaces</artifactId>  
		    <version>5.2</version>  
		</dependency>
----

Sin embargo, subir JSF de la versión 2.1 a la 2.2 no es tan simple. El proceso para añadir un nuevo módulo con JSF 2.2 en nuestro servidor JBoss EAP 6.3 no es directo. He intentado seguir el procedimiento existente en internet sin resultados. En resumen el proceso pasa por bajar una aplicación Maven desde Github que genera un fichero CLI que realiza el deploy de los tres slots para los tres módulos que se ven afectados por la actualización. Sin embargo uno de los slots da problemas ya que parece que el script está actualizado para operar con las versiones iniciales del servidor Wildfly y no con JBoss EAP.

A la vista de lo anterior se optará por instalar el nuevo servidor Wildfly en su última versión, la 9.0.1, y así tener disponible además una plataforma Java EE 7 completa. Lo primero será descargar el fichero de instalación del servidor desde http://wildfly.org/downloads/[aquí]. Tenéis que elegir la primera de las opciones en la lista, etiquetada con Java EE7 Full & Web Distribution. En el momento de redactar este Post ya estaba disponible Wilfly 10, así que podéis instalarlo en vez de el 9. Entiendo que no debe afectar en cuento a instalación e integración con Eclipse.

NOTE: Descargaos también los _Quickstarts_ porque os van a venir muy bien como material de consulta en las etapas iniciales de la implementanción de un nuevo proyecto sea cual sea su naturaleza.

Después de instalar el nuevo servidor y antes de iniciarlo debemos añadir un usuario. Para ello tenemos que ejecutar el archivo por lotes _bin\add-user.bat_.

Una vez instalado WildFly lo añadimos a Eclipse como nueva unidad de ejecución. La versión de las JBoss Tools sólo ofrecía un conector para la versión 8 pero después de las pruebas de arranque y parada se comprueba no hay problemas con esto.

NOTE: Si queréis practicar con el programa de control de versiones Git podéis hacer un fork de la aplicación jdrone en vuestra cuenta de GitHub y a continuación crear un repo local Git que os permita realizar pruebas sobre la aplicación en vuestra máquina.

Bien, después de actualizar a Wilfly 9 ó 10 ¿Qué cambios tenemos que hacer en nuestro proyecto? En primer lugar tendremos que adaptar las dependencias Maven a las del nuevo servidor, un proceso sin demasiada complicación. Podéis consultar el contenido del fichero _pom.xml_ en GitHub.

Se ha refactorizado además el ciclo de construcción de modo que ahora existe un profile _despliegue-recursos_ que se debe ejecutar la primera vez que despleguemos la aplicación, o bien cuando los recursos hayan sido eliminados del mismo por cualquier motivo. Tenéis también que crear un nueva configuración de ejecución: Botón derecho sobre proyecto y _Run As_ > _Run Configurations..._  Botón derecho sobre _Maven build_ > _New_.  En la entrada _Goals_ escribid `clean install -Pdespliegue-recursos` y dad un nombre al nuevo perfil.

En segundo lugar, como vamos a subir desde JSF 2.1 a 2.2 tenemos que actualizar los espacios de nombres en el nodo raiz del fichero _faces-config.xml_. Además tendremos que actualizar la faceta JavaServer Faces del proyecto. La desmarcamos, esperamos a que se desinstale y la volvemos a marcar. Al añadir de nuevo la opción _JSF Implementation Library_ dejadla así _Type > Disable Library Configuration_.

Para comprobar que JSF 2.2 funciona correctamente modificamos nuestra página _index.xhtml_ para adaptarla a HTML5 y JSF 2.2, añadiendo además una etiqueta nueva en la versión 2.2.

Para la adaptación a HTML 5 actualizamos la página así:

`<!DOCTYPE html>`

Para la adaptación a JSF 2.2 cambiamos los espacios de nombres:

`<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:h="http://xmlns.jcp.org/jsf/html"
	xmlns:f="http://xmlns.jcp.org/jsf/core">`

Finalmente sustituimos:

`<f:event listener="#{disponibilidadBean.listaEstadoDronesPorFecha()}" type="preRenderView" />`

por:

`<f:viewAction action="#{disponibilidadBean.listaEstadoDronesPorFecha()}" onPostback="true"></f:viewAction>`

Además ahora no se admitirán los típicos caracteres de espaciado `\&nbsp;` y tendremos que sustituirlos por el equivalente código unicode `\&#160;`.

La etiqueta `viewAction` es nueva en JSF 2.2. Asocia un evento a una página ofreciendo más flexibilidad que la etiqueta `event` para acciones de precarga de datos para una página. La forma en que se usa en la página de consulta de listado de drones no es la habitual, y por eso es necesario añadir el atributo `onPostback="true"`, sin embargo, a continuación veremos un uso adecuado tanto en la página de maestro como en la de detalle.

Bien, con el diseño inicial de las páginas listo podemos empezar con el desarrollo. Aquí no lo veremos paso a paso como en Posts anteriores sino que, sobre el código del proyecto que habéis bajado de GitHub, intentaremos entender cómo se desarrolla en JSF. Nos centraremos en la capa de presentación y comentaremos la capa de servicio al final ya que en un CRUD no tiene demasiado interés por su simplicidad.

=== La página de maestro: trabajos.xhtml.

Pensemos en la pantalla de maestro y sus distintos elementos. Tenemos un listado con datos de sólo lectura, los botones Borrar icon:trash[], Editar icon:pencil[] y Ver icon:search[] asociados a cada entidad del listado y los botones Salir y Crear a nivel de pantalla:

* El listado de entidades: La página de maestro debe mostrar inicialmente, es decir en la Initial Request, todos los Trabajos. Debemos tener los datos disponibles por tanto antes de la fase Render Response. Esto lo conseguimos con la etiqueta viewAction. Esta etiqueta añade un evento al ciclo de vida de JSF de la request Initial Request a la página que la contiene, que es justo lo que necesitamos.

[source,xhtml,indent=0]
----
	<f:metadata>
		<f:viewAction action="#{trabajosBean.actualizaModeloTrabajos()}"></f:viewAction>
	</f:metadata>
----

El método `trabajosBean.actualizaModeloTrabajos()` realiza una llamada a la capa de servicio y actualiza el Modelo en el backing bean, y a continuación la página es renderizada en el servidor en la fase Render Response. Durante esta fase entran en juego los bindings establecidos en la tabla dataTable, que tiran del Modelo para renderizar cada campo de datos de cada Trabajo. El código muestra el binding para la primera columna de la tabla:

[source,xhtml,indent=0]
----
		<p:dataTable id="tabla" var="trabajo" value="#{trabajosBean.trabajos}">
			<!-- datos -->
		    <p:column headerText="N. Registro">
		        <h:outputText value="#{trabajo.numeroDeRegistro}" />
		    </p:column>
----

* Los botones de acción a nivel de entidad: La página ya ha sido renderizada y se muestra correctamente en nuestro navegador. Si el código de la página es correcto cuando pulsemos alguno de los botones Borrar, Editar o Ver se debe obtener la funcionalidad deseada.

El botón +++<span class="boton">+++Ver+++</span>+++ en general se implementa para que se navegue a otra página donde se muestra el detalle de la entidad seleccionada, sin embargo aprovecharemos las capacidades de Primefaces para mostrar ventanas emergentes. El código sería:

[source,xhtml,indent=0]
----
<p:commandButton update=":formulario:trabajoDetail" icon="ui-icon-search" oncomplete="PF('trabajoDialog').show()">
	<f:setPropertyActionListener value="#{trabajo}" target="#{trabajosBean.trabajoSeleccionado}"></f:setPropertyActionListener>
</p:commandButton>
----

La secuencia de acciones tras pulsar el botón sería la siguiente: La etiqueta `setPropertyActionListener` actualiza la variable del Modelo `trabajosBean.trabajoSeleccionado` del que tira el cuadro de diálogo. La llamada Ajax actualiza el panel de datos `:formulario:trabajoDetail` y finalmente el diálogo es mostrado con la llamada Javascript `PF('trabajoDialog').show()`. Lo que tenemos es una Postback Request a la propia página.

El botón +++<span class="boton">+++Editar+++</span>+++ sí lleva a cabo una navegación. El código es el siguiente:

[source,xhtml,indent=0]
----
		        <p:button outcome="/trabajo" icon="ui-icon-pencil">
		        	<f:param name="idTrabajo" value="#{trabajo.idTrabajo}"></f:param>
		        </p:button>
----

Como vemos lo único que hace es navegar a la página de creación / edición del detalle. Para esto se usa la etiqueta `button`, no la `commandButton`. Es necesario enviar un parámetro en la request que indique el Trabajo que se va a editar. Se lleva a cabo por tanto una Initial Request a la página de detalle.

Por último el botón +++<span class="boton">+++Borrar+++</span>+++ genera, al igual que el botón Ver, una Postback Request, que como ya sabemos, inicará un ciclo completo de JSF. Será un ciclo Ajax, que es el comportamiento por defecto para los botones en Primefaces. En la fase Invoke Application de este ciclo se llamará al método de borrado `trabajosBean.eliminar(trabajo)` del backing bean. El código completo es:

[source,xhtml,indent=0]
----
		        <p:commandButton 
			        action="#{trabajosBean.eliminar(trabajo)}"
			        update=":formulario:paneltrabajos"
			        icon="ui-icon-trash">
		        		<p:confirm header="Borrado de trabajo" message="Pulsa Confirmar para confirmar acción" icon="ui-icon-alert" />
		        </p:commandButton>
----

En general para las acciones de borrado, ya sea físico o lógico, es conveniente presentar un cuadro de diálogo de confirmación al usuario. En Primefaces es muy fácil de implementar usando un cuadro de diálogo global.

Bien, nos queda por ver los dos botones a nivel de página, Salir y Crear. Como véis en la figura que muestra el diseño de la página, he colocado estos botones encima del listado de Trabajos, creo que así se mejora la experiencia de usuario ya que los botones siempre van a estar en la misma posición independientemente del número de filas del listado y además se muestran en una posición más accesible, sobre todo en pantallas de tamaño reducido.

El botón +++<span class="boton">+++Salir+++</span>+++ simplemente navega a la página de inicio:

[source,xhtml,indent=0]
----
<p:button value="Salir" outcome="/index" />
----

Y el botón +++<span class="boton">+++Crear+++</span>+++ es igual de simple, navega a la misma página a la que nos lleva el botón Editar pero sin especificar ningún parámetro:

[source,xhtml,indent=0]
----
<p:button value="Crear" outcome="/trabajo" />
----

Y hasta aquí los aspectos más importantes de la página de maestro.

=== La página de detalle: trabajo.xhtml.

Como hemos comentado esta pantalla es más compleja que la de maestro y su complejidad dependerá del número y tipo de relaciones de la entidad que queremos gestionar.

Usaremos la misma página tanto para la edición como para la creación de una entidad Trabajo. Veamos la secuencia de acciones que ocurren cuando navegamos a la página de detalle, tanto en el caso de una edición como en el caso de una creación. Recordemos que lo que tenemos es una Initial Request.

En primer lugar una instancia del backing bean es creada. Justo después se ejecuta el método anotado con _@PostConstruct_, que crea una instancia  de la entidad gestionada, Trabajo. A continuación se acualiza el modelo con el valor del parámetro _idTrabajo_ si existe, y finalmente se ejecuta el método especificado en la etiqueta _viewParam_:

[source,xhtml,indent=0]
----
	<f:metadata>
		<f:viewParam name="idTrabajo" value="#{trabajoBean.trabajo.idTrabajo}"></f:viewParam>
		<f:viewAction action="#{trabajoBean.actualizaModeloTrabajo()}"></f:viewAction>
	</f:metadata>
----

Si el usuario navegó para una creación, el parámetro es nulo y el atributo _trabajo_ del Modelo no varía. En cambio en una edición el campo _idTrabajo_ se actualiza con el valor del ID seleccionado en la pantalla de maestro.

En el método _actualizaModeloTrabajo()_ comprobamos el valor del ID y si no es nulo actualizamos el Modelo para que en la fase Render Response se muestren los datos del trabajo que el usuario desea editar.

Como antes, tenemos nuestra página lista para la creación o la edición. El botón +++<span class="boton">+++Salir+++</span>+++ es simple, se trata de un botón de cancelación:

`<p:button value="Salir" outcome="/trabajos.xhtml"/>`

Ejecuta una navegación GET a la página de maestro. Esta simplicidad es posible porque la cancelación de la sesión de edición de un Trabajo no requiere ninguna acción adicional. Si precisaramos realizar alguna acción, por ejemplo para liberar recursos a nivel del ámbito de sesión o de aplicación, o para realizar una escritura en base de datos para grabar la fecha y hora de la cancelación, entonces no nos valdría con lo anterior y tendríamos que elegir entre alguna de las dos soluciones siguientes, siempre usando un componente de tipo "command":

* Configurar el botón para que se procese sólo a sí mismo en la llamada Ajax. De esta manera el resto del formulario no se ve afectado y conseguimos evitar la ejecución de conversiones y validaciones:

`<p:commandButton value="Salir" process="@this" action="/trabajos.xhtml?faces-redirect=true" />`

* Configurar el botón con el modificador _inmmediate_ a true. De esta manera la accion asociada a la cancelación se realiza en la fase de Apply Request Values y luego se salta a la fase de Render Response, ignorando como en el caso anterior conversiones y validaciones:

`<p:commandButton value="Salir" action="/trabajos.xhtml?faces-redirect=true" immediate="true" />`

Es importante tener claro que durante una sesión de edición sólo tenemos que guardar los cambios en la correspondiente variable del Modelo en el backing bean, y llamar al método de la capa de Servicio para persistir los cambios sólo al final de la sesión, cuando el usuario pulse el botón Aceptar. La variable del backing bean será una entidad _detached_ en el caso de una edición y una entidad _new_ en el caso de una creación. En el método de Servicio simplemente metemos la entidad en el contexto de persistencia convirtiéndola en _managed_, y por último antes de salir del método JTA ordena el commit que persiste los cambios.

Nos queda el botón +++<span class="boton">+++Aceptar+++</span>+++. Su aspecto puede intimidar un poco a primera vista:

[source,xhtml,indent=0]
----
<p:commandButton id="aceptar" value="Aceptar" action="#{trabajoBean.aceptar}" update="@(:input:not(.notsend)) mensajes" process="@(:input:not(.notsend))" oncomplete="ajustaPosicionEtiquetas();" />
----

Bien, primero lo sencillo. Se trata de un botón de comando, y que por lo tanto genera una petición Ajax de tipo Postback de la propia página. Esto dispara en el servidor un ciclo de vida completo de JSF. Se llevarán a cabo las conversiones, validaciones y actualización del Modelo para el subconjunto de valores que nos interesa, a continuación se ejecutará la llamada al método de servicio y se actualizará la zona adecuada de la página. Finalmente hay un ajuste dinámico de estilo. Veamos más detenidamente cada atributo del botón:

* process y update: El primero determina los elementos que enviamos y en segundo lo que actualizamos en la llamada Ajax. Lo interesante aquí es que se ha tenido que usar un selector complejo para definir el conjunto de elementos. El motivo de esto es que se ha usado un componente para maquetar la página que englobaba a la entidad Trabajo y también a sus PuntosRuta y como no puedo meter un formulario dentro de otro, tanto la entidad padre como las hijas están en el mismo formulario y de ahí que sea necesario filtrar lo que se envía al servidor. Cuando pulse Aceptar sólo deberé enviar al servidor los campos de la entidad Trabajo y excluir los tres campos de introducción de un PuntoRuta. Para esto uso la capacidad de PrimeFaces de usar selectores jQuery:

`@(:input:not(.notsend))`

El selector toma todos los elementos de entrada del formulario, y luego se excluyen los de la clase _.notsend._ De modo que si asignamos a los tres campos de entrada de PuntoRuta esta clase evitaremos que intervengan en el submit generado al pulsar el botón Aceptar.

* action: Indica la llamada a la capa de Servicio para persistir el Trabajo. Tenemos un mismo método tanto para la creación como para la edición de la entidad. Esto es posible porque como se ha comentado en JPA con un merge metemos en el contexto de persistencia tanto una entidad new como una detached.

* oncomplete: Llama a una función JS que restablece el estilo del elemento padre de las etiquetas de campos que ocupan una altura extra, _Descripción_ y _Puntos de Ruta_. El problema aquí es que en CSS no existe una manera de seleccionar un elemento conocido su hijo y tenemos que recurrir por tanto a JS, de modo que cada vez que la pantalla se refresca hay que reescribir el estilo. Esto es un ejemplo de cómo a veces para conseguir una buena experiencia de usuario es necesario usar técnicas un poco atípicas.

Bien, hasta aquí los aspectos generales de la pantalla de detalle. A continuación y para concluir con este Post vemos cómo implementar una plantilla de Facelets.

== Uso de plantillas: Una plantilla adaptativa para jDrone

Una interfaz adaptativa, en inglés _responsive_, se hace necesaria casi en cualquier proyecto hoy en día dada la variabilidad del tamaño de pantalla de los distintos dispositivos: Laptops, tablets, smartphones... En una aplicación JSF una buena alternativa para esto es usar el componente _Grid CSS_ de Primefaces, que permite realizar la maquetación de las páginas del proyecto definiendo las zonas comunes: Cabecera, menú, barra de navegación, sides, zona central principal y pie. Asimismo, aunque no se ha incluido en jDrone, es interesante el uso de la clase CSS _ui-fluid_ que va a darnos una interfaz fluida cálculando la posición y tamaño de cada componente dependiente del dispositivo. Grid CSS no es más que una librería de estilos, similar a Bootstrap, pero compatible con JSF y Primefaces. 

Antes de empezar a implementar lo mejor es tomar lápiz y papel o una herramienta como Inkscape y dibujar un boceto del layout de la página completa que queremos y así tener claro los _divs_ que voy a necesitar para crear las áreas de la pantalla.

Una plantilla es una página XHTML privada que define la estructura y el contenido común de todas las páginas de la aplicación que la usan y una serie de elementos _<ui:insert...> para definir los puntos de inserción del contenido variable. Podéis consultar el contenido de la plantilla usada en jDrone abriendo el fichero _\jdrone\src\main\webapp\WEB-INF\plantillas\plantilla.xhtml_.

Por otro lado tenemos las páginas públicas de la aplicación, que ban a usar la plantilla incluyendo el contenido variable mediante la inclusión de elementos _<ui:define...>_. Básicamente una página tendrá este aspecto:

[source,xhtml,indent=0]
----
	<ui:composition...>
    	<ui:define name="central">
        	...
        </ui:define>
        <ui:define name="logo">
       		<ui:include... />
        </ui:define>
        ...
    </ui:composition>
----

El contenido de la zona de contenido variable, _central_, se define en cada página en general al principio para mayor claridad dado que aquí el orden no afecta. La zona del logo la hacemos también insertable aunque en todas las páginas aparecerá como un include, esto nos da la posibilidad de tener páginas especiales que prescindan del logo si por ejemplo necesitamos espacio extra.

La página de consulta de drones disponibles en una fecha del Post anterior se ha movido desde _index.xhtml_ a _consulta-inicial.xhtml_ y tras adaptarla al uso de la plantilla queda así:

[source,xhtml,indent=0]
----
<ui:composition xmlns:ui="http://xmlns.jcp.org/jsf/facelets"
                xmlns:h="http://xmlns.jcp.org/jsf/html"                
                template="/WEB-INF/plantillas/plantilla.xhtml"
                xmlns:p="http://primefaces.org/ui"
                xmlns="http://www.w3.org/1999/xhtml"
                xmlns:f="http://xmlns.jcp.org/jsf/core">

    <ui:define name="central">
    	<!-- estilo aplicable a la página -->
        <f:facet name="last">
            <h:outputStylesheet library="css" name="estilo.css"/>
        </f:facet>
        <!-- acción asociada a la pantalla -->
        <f:metadata>
			<f:viewAction action="#{disponibilidadBean.listaEstadoDronesPorFecha()}" onPostback="true"></f:viewAction>
        </f:metadata> 

		<!-- contenido de zona central -->
	¡Hola mundo!
	<br />

	<h:form>
		<h:outputText
			value="Consulta de drones realizando trabajos en una fecha" />
		<br />
		<br />
		<h:messages />
		<br />
		<h:outputText
			value="Introduce la fecha y la hora en el formato indicado:" />
		<br />
		<h:outputLabel value="Fecha (dd-mm-aaaa)" for="fecha" />&#160;
		<h:inputText id="fecha" value="#{disponibilidadBean.fecha}"
			required="true">
			<f:convertDateTime pattern="dd-MM-yyyy" />
		</h:inputText>
		<br />
		<h:outputLabel value="Hora (0-23:0-59)" for="hora" />&#160;
		<h:inputText id="hora" value="#{disponibilidadBean.hora}"
			required="true">
			<f:convertDateTime pattern="HH:mm" />
		</h:inputText>
		<br />
		<br />
		<h:commandButton value="Consultar" />
	</h:form>
	<br />
	<h:dataTable value="#{disponibilidadBean.drones}" var="drone" style="width:100%;"
		styleClass="tabla-general" headerClass="tabla-general-cabecera" 
		rowClasses="tabla-general-impar,tabla-general-par">

		<h:column>
			<!-- column header -->
			<f:facet name="header">Número de Serie</f:facet>
			<!-- row record -->
    				#{drone.numeroDeSerie}
    			</h:column>
		<h:column>
			<f:facet name="header">Modelo</f:facet>
    				#{drone.modelo}
    			</h:column>
		<h:column>
			<f:facet name="header">Autonomía</f:facet>
    				#{drone.autonomia}
    			</h:column>
		<h:column>
			<f:facet name="header">Número de Motores</f:facet>
    				#{drone.numMotores}
    			</h:column>
		<h:column>
			<f:facet name="header">Peso Máximo Despegue</f:facet>
    				#{drone.pesoMaximoDespegue}
    			</h:column>

	</h:dataTable>
			
	</ui:define>
	
	<!-- contenido de zona logo -->
    <ui:define name="logo">
        <ui:include src="/WEB-INF/paneles/panelLogo.xhtml" />
    </ui:define>

	<!-- contenido de zona barra menu -->
    <ui:define name="menu">
        <ui:include src="/WEB-INF/paneles/panelMenu.xhtml" />
    </ui:define>
    
	<!-- TODO: contenido de otras zonas... -->

</ui:composition>
----

Se tienen tres puntos de definición de contenido, el punto _central_, donde se ha añadido el contenido de la página antigua, en el punto _menu_, donde incluiremos un menú como veremos a continuación, y en el punto _logo_ para el logo de la aplicación y de la empresa. 

El logo se implementa con un elemento _<ui:composition... >_ sin elementos `<ui:define...>` al contrario que el resto de páginas cliente de la plantilla. Se ha incluido aquí una sencilla animación realizada con la librería Javascript jQuery para que, si aún no la conocéis, tengáis una primera toma de contacto. Es muy importante conocerla bien porque acelera el desarrollo de la parte de cliente y permite llegar más lejos con Primefaces, que está basado en jQuery. Para ver la animación sólo tenéis que pasar el puntero del ratón por encima del logo jDrone. 

NOTE: No debemos añadir jQuery a un proyecto que use Primefaces. No es habitual, pero si una página de nuestro proyecto no usa ninguna estiqueta de Primefaces entonces incliremos de manera explícita en la página la librería jQuery embebida en Primefaces añadiendo el código:

[source,xhtml,indent=0]
----
<h:outputScript library="primefaces" name="jquery/jquery.js" target="head" />
<h:outputScript library="primefaces" name="jquery/jquery-plugins.js" target="head" />
----

Con nuestra página de consulta ya maquetada lo siguiente es añadir el menú de opciones de la aplicación a la página. Optaremos por la clásica barra de menú de las aplicaciones de Escritorio. Como suele ocurrir cuando necesitamos algún elemento para la capa de presentación Primefaces nos da la solución, en este caso con el componente _<p:MenuBar...>_. Tened en cuenta que la versión 5.2, abierta a la comunidad y usada en nuestro programa, tiene casi 150 componentes. Usando este componente en un par de minutos dibujamos las opciones y submenús que tengamos previstos para la aplicación. Finalmente, para situar el menú en la página, lo metemos, al igual que el logo, en un panel, y lo situamos en la plantilla añadiendo a la misma un elemento _<ui:insert...>_.

Arrancamos el servidor y ejecutamos nuestro ciclo de construcción para ver el aspecto en pantalla. Personalmente no me convence el aspecto por defecto del menú por lo que acudimos de nuevo a Primefaces y vemos que es muy sencillo dar un aspecto distinto a los componentes simplemente eligiendo otro _Theme_. Además de paso activamos los iconos de FontAwesome añadiendo el correspondiente parámetro en el fichero _web.xml_ y así disponer de una mayor variedad de iconos.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig005.png[]

Para cambiar el _Theme_ tenemos que añadir una dependencia de Maven, elegimos el _Theme bluesky_, más acorde con la Marca de la compañía cliente:

[source,xml,indent=0]
----
  <dependency>
    <groupId>org.primefaces.themes</groupId>
    <artifactId>bluesky</artifactId>
    <version>1.0.10</version>
  </dependency>
----

Y añadir un parámetro en el descriptor de despliegue, _web.xml_:

[source,xml,indent=0]
----
  <context-param>
    <param-name>primefaces.THEME</param-name>
    <param-value>bluesky</param-value>
  </context-param>
----

Guardamos los cambios. Si abrimos el fichero _pom.xml_ observamos que se muestra un error en la dependencia añadida, esto es debido a que esta dependencia no está en el repositorio Central. Tenemos por tanto que añadir el repositorio de Primefaces a nuestra configuración de Maven. Podemos hacerlo directamente desde la sugerencia que nos muestra Eclipse al poner el puntero del ratón sobre el error. Introducid los datos tal y como aparecen en la siguiente figura:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig010.png[]

Pulsamos _OK_ y _Finish_. Para afinar el estilo de la barra de menú aún más podemos modificar el estilo aplicado por el framework a los componentes que forman el menú. En la documentación de Primefaces aparecen estos estilos, pero lo más práctico es ayudarnos de las herramientas de desarrollador de Chrome o Firefox (F12) para localizar fácilmente los estilos aplicados a cada elemento sobre la propia pantalla y editarlos para ver los cambios on the fly.


Para estilizar los menús añadid al principio del fichero _plantilla.css_ lo siguiente: 

[source,css,indent=0]
----
.ui-menubar{
	height: 1.em;	
	padding:0em !important;	
}
.ui-menuitem{
	height: 1.8em;
}
----

Desplegad los cambios en WildFly y comprobad que el nuevo aspecto de la pantalla sea similar a éste:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig015.png[]

En el próximo Post terminaremos de analizar el código fuente de las pantallas de gestión de Trabajos, esta vez bajando al detalle, y analizando las técnicas más interesantes. Hasta pronto!