= Desarrollo de una aplicación desde cero: El origen de datos y la carga inicial de datos.
La metaweb
:hp-tags: JPA, Hibernate, persistencia, datasource, carga inicial de datos
:published_at: 2015-06-12

En este post veremos en primer lugar qué es un origen de datos, su relación con la capa de persistencia, y su configuración e instalación adaptado a las caraccterísticas de nuestra aplicación. Y por otro lado implementaremos una carga de datos inicial simple que si bien no representa un ejemplo de carga de datos en un proyecto real sí servirá para nuestro propósito, y además nos mostrará un primer ejemplo de persistencia de datos con JPA y un tipo interesante de bean EJB introducido en la versión 6 de Java EE.

Un origen de datos o datasource es un recurso de servidor que permite a una aplicación comunicarse con el gestor de la base de datos, a través del proveedor de persistencia, para realizar operaciones de consulta y modificación sobre un esquema de datos. El origen de datos necesita a su vez un driver, que consiste en un conjunto de librerías que traducen los comandos del proveedor de datos en comandos específicos de la base de datos utilizada: Oracle, PostgreSQL, MySQL, etc. 

La instalación del datasource puede hacerse de distintas maneras. En nuestro caso la incluiremos dentro del ciclo de construcción del proyecto, en el archivo pom.xml, para que de este modo tengamos toda la información necesaria en un mismo sitio. Tambíen veremos sin embargo una manera de instalar el datasource en el servidor de forma manual, no automatizada, ya que es como comúnmente se hace en proyecto reales.

Bien, empezamos. Abrimos Eclipse y a continuación el fichero pom.xml del proyecto. Añadimos la dependencia correspondiente al driver JDBC de Derby del que tirará el datasource con un copia pega del siguiente fragmento de XML dentro del elemento <dependencies>:

[source,xml,indent=0]
----
	<dependency>
		<groupId>org.apache.derby</groupId>
		<artifactId>derby</artifactId>
		<version>10.11.1.1</version>
		<scope>runtime</scope>
	</dependency>
----

Como vemos el scope de la dependencia es _runtime_, ya que no es necesario en tiempo de compilación pero si cuando la aplicación se esté ejecutando en el servidor. Es decir, el proveedor de persistencia lo invocará para llevar a cabo las operaciones contra la base de datos, pero en ningún lugar de nuestro código usaremos ninguna de las clases de las librerías del driver directamente.

Y ahora viene lo interesante, hacemos uso del plugin de Maven para el servidor JBoss para llevar a cabo de forma automatizada las tareas de despliegue que necesitamos, que por orden son las siguientes:

* Desinstalar una instalación pevia de la aplicación si existía.
* Instalar el artefacto correspondiente al driver a nivel de servidor como un despliegue estándar.
* Instalar el datasource como recurso de servidor si éste no está ya instalado.
* Y finalmente desplegar nuestra aplicación.

Y todo esto haciendo un simple click de ratón. Es un buen ejemplo de como Maven puede ayudarnos a centrarnos en implementar el diseño de nuestra aplicación evitándonos tener que dedicar tiempo a tareas que no son puramente de desarrollo.

Copiamos y pegamos en el fichero pom.xml lo siguiente bajo el elemento _project/build/plugins_. Recordad que podemos formatear el XML con la hotkey Ctrl + Shift + F para que quede más ordenado después de pegar el contenido.

[source,xml,indent=0]
----
	<plugin>
		<groupId>org.jboss.as.plugins</groupId>
		<artifactId>jboss-as-maven-plugin</artifactId>
		<version>7.6.Final</version>

		<executions>
			<execution>
				<id>undeploy</id>
				<phase>install</phase>
				<goals>
					<goal>undeploy</goal>
				</goals>
			</execution>
			<execution>
				<id>deploy-driver</id>
				<phase>install</phase>
				<configuration>
					<groupId>org.apache.derby</groupId>
					<artifactId>derby</artifactId>
					<name>derby.jar</name>
				</configuration>
				<goals>
					<goal>deploy-artifact</goal>
				</goals>
			</execution>
			<execution>
				<id>add-datasource</id>
				<phase>install</phase>
				<configuration>
					<address>subsystem=datasources,data-source=DerbyDS</address>
					<resource>
						<enableResource>true</enableResource>
						<properties>
							<connection-url>jdbc:derby:c:\BD\drones;create=true</connection-url>
							<driver-class>org.apache.derby.jdbc.EmbeddedDriver</driver-class>
							<jndi-name>java:jboss/datasources/DerbyDS</jndi-name>
							<enabled>true</enabled>
							<enable>true</enable>
							<pool-name>DerbyDS</pool-name>
							<user-name>root</user-name>
							<password>root</password>
							<driver-name>derby.jar</driver-name>
							<use-ccm>false</use-ccm>
							<force>true</force>
						</properties>
					</resource>
				</configuration>
				<goals>
					<goal>add-resource</goal>
				</goals>
			</execution>
			<execution>
				<id>deploy</id>
				<phase>install</phase>
				<goals>
					<goal>deploy</goal>
				</goals>
			</execution>

		</executions>
	</plugin>
----

En general bajo el elemento <plugins> podemos declarar plugins de Maven para diferentes propósitos:

* Ejecutarlo en nuestro proyecto de forma manual, bien a través de la linea de comnandos o bien desde Eclipse en la opción _Run > Run Configurations..._.
* Cambiar la configuración de un plugin del ciclo de vida por defecto.
* Incluir la ejecución de uno o más goals como parte de alguna fase del ciclo de vida por defecto. Para esto debemos declarar el plugin, y añadir un elemento <execution> por cada goal/fase que queramos añadir.

El fragmento añadido es un ejemplo del tercer caso y ejecuta cuatro goals del plugin del servidor JBoss en la fase install del ciclo de vida por defecto. Los goals se ejecutan en el orden en que aparecen en el fichero pom.xml. Para consultar la documentación y tener una idea de las posibilidades del plugin del servidor JBoss podéis ir a este https://docs.jboss.org/jbossas/7/plugins/maven/latest/index.html[enlace].

Aprovechamos que estamos tocando el pom.xml para añadir un elemento <plugin> adicional que evitará de momento la ejecución de las pruebas unitarias, en la fase Test,  hasta que tengamos alguna prueba implementada. Esto sería un ejemplo del segundo tipo visto en la lista anterior.

[source,xml,indent=0]
----
	<plugin>
		<groupId>org.apache.maven.plugins</groupId>
		<artifactId>maven-surefire-plugin</artifactId>
		<version>2.18.1</version>
		<configuration>
			<skipTests>true</skipTests>
		</configuration>
	</plugin>
----

Hasta aquí el despliegue automatizado con Maven. Veamos un despliegue equivalente pero realizado de forma manual. La manera en que se añaden nuevas librerías a nivel de servidor es diferente desde la versión 6 de JBoss, y se basa en módulos. Podéis leer https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6/html/Development_Guide/chap-Class_Loading_and_Modules.html[esta documentación] para entender mejor el nuevo mecanismo de carga de clases y recursos en JBoss 6+.

De hecho en el despligue anterior del driver desde Maven el servidor ha generado un modulo. En este caso un módulo dinámico con el nombre _deployment.derby.jar_ asociado al despliegue de la librería derby.jar. En el despliegue manual lo que creamos es un módulo estático, que se carga en el arranque del servidor y no asociado al despliegue de una aplicación como en el caso del dinámico.

En resumen hay que hacer dos cosas. La primera es añadir un nuevo módulo estático para incluir el driver JDBC de Derby en el servidor, y en segundo lugar tenemos que añadir la configuración del datasource en el fichero de configuración del servidor. Lógicamente tenéis que optar por una de las dos estrategías, la automatizada con Maven ya vista o ésta que vamos a ver ahora. Para librerías de uso general compartidas por varias aplicaciones es más conveniente delegar en el equipo de administradores de sistemas la creación de los módulos estáticos que requiramos.

Los pasos a seguir para la instalación manual son:

* Creación del módulo para la carga del driver derby.jar:

** Descargar el fichero .zip de derby en http://db.apache.org/derby/releases/release-10.10.1.1.html[esta dirección].

** Extraer el fichero \lib\derby.jar y copiarlo en un lugar temporal, por ejemplo en el escritorio.

** Ir a la carpeta _C:\TALLER\Servidor\EAP-6.3.0\jboss-eap-6.3\modules\system\layers\base\org\apache\_

** Crear dentro de la anterior la carpeta _derby\main\_

** Situarnos dentro de la nueva carpeta.

** Copiar el fichero derby.jar en la carpeta.

** Con un editor de textos, por ejemplo Notepad++, crear un fichero con el nombre _module.xml_ en la misma carpeta y con el siguiente contenido:

[source,xml,indent=0]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<module xmlns="urn:jboss:module:1.0" name="org.apache.derby">
		<resources>
			<resource-root path="derby.jar"/>
		</resources>
		<dependencies>
			<module name="javax.api"/>
		</dependencies>
	</module>
----

* Añadir el datasource:

** Ir a la carpeta _C:\TALLER\Servidor\EAP-6.3.0\jboss-eap-6.3\standalone\configuration\_

** Abrir el fichero _standalone.xml_ con un editor de textos.

** Añadir el siguiente fragmento XML dentro del elemento _<subsystem xmlns="urn:jboss:domain:datasources:1.2"><datasources>_:

[source,xml,indent=0]
----
  <datasource jndi-name="java:jboss/datasources/DerbyDS" pool-name="DerbyDS" enabled="true" use-ccm="false">
      <connection-url>jdbc:derby:c:\BD\drones;create=true</connection-url>
      <driver>org.apache.derby</driver>
      <security>
          <user-name>root</user-name>
          <password>root</password>
      </security>
      <validation>
          <validate-on-match>false</validate-on-match>
          <background-validation>false</background-validation>
      </validation>
      <statement>
          <share-prepared-statements>false</share-prepared-statements>
      </statement>
  </datasource>
----

** Añadir también el siguiente fragmento XML dentro del elemento _<subsystem xmlns="urn:jboss:domain:datasources:1.2"><datasources><drivers>_:

[source,xml,indent=0]
----
	<driver name="org.apache.derby" module="org.apache.derby">
		<xa-datasource-class>org.apache.derby.jdbc.EmbeddedXADataSource</xa-datasource-class>
	</driver>
----

Y con esto bastaría para instalar de forma permanente un origen de datos específico para nuestra aplicación y por otro lado un driver de acceso a bases de datos Derby que puede ser usado por cualquier aplicación que despleguemos en el servidor.

Veamos lo más relevante del contenido XML:

* Fichero module.xml: Es el fichero de configuración de un módulo en JBoss. Un módulo representa una serie de recursos o bien una serie de dependencias o ambas cosas como en nuestro caso. El nombre del módulo es _org.apache.derby_ y el fichero module.xml debe estar en la carpeta _RUTA_BASE_MODULOS\org\apache\derby\main\_. Dentro de esta carpeta también está el recurso, derby.jar. Nuestro módulo dependerá del módulo "javax.api" que representa a su vez múltiples dependencias con paquetes del grupo javax que el driver necesitará para su ejecución.

* Elemento <datasource>: Define un origen de datos identificado por un nombre JNDI del tipo _java:jboss/datasources/NOMBRE_DS_. Como nombre del pool podemos usar el que queramos. El elemento <connection-url> nos dice que ruta de la base de datos estará en el disco duro en la ruta _C:\BD\drones\_ y que se creará una base de datos vacía si no existía ya anteriormente. En el elemento <driver> pondremos el nombre del módulo que hemos creado.

Vamos con la segunda parte del post, implementar una carga inicial de datos. He decidido hacerlo desde la propia aplicación porque así podemos ver un primer ejemplo de persistencia de datos con JPA y además un tipo de bean EJB que permite realizar acciones en el inicio de una aplicación web.

Necesitamos una manera de ejecutar el código Java de carga en el inicio de la aplicación y para esto tenemos que ínstanciar un bean en ese momento y colocar el código en un método anotado con _@PostConstruct_ para que se ejecute sin necesidad de una llamada explícita al mismo. La carga del bean podemos hacerla de tres maneras diferentes usando en cada caso una tecnología diferente: EJB, JSF o bien CDI. Vemos cada caso y al final decidimos cual es el más conveniente para nosotros.

* EJB: A través de un bean de sesión singleton. Se trata de un bean con estado que se carga una sola vez la primera vez que se hace referencia al mismo desde la aplicación. La anotación _@Startup_ se usa para obligar a una carga en el arranque de la aplicación. Aquí el estado no nos interesa en cualquier caso. La definición de la clase para el bean sería:

[source,java,indent=0]
----
	@Singleton
	@Startup
	@ConcurrencyManagement(BEAN)
	public class PropertyRegistry {
		@PostConstruct
		public void applicationStartup() {
			// carga inicial
		}
	}
----

* JSF: Esta alternativa, aunque la cito, de entrada no la usaremos ya que pasa por usar un atributo en la anotación _@ManageadBean_, que estará deprecada probablemente en la siguiente versión de JSF, la 2.3. En vez de esta anotación tenemos siempre que usar una de entre las que expresan el ámbito del bean, ya sea una anotación CDI o una compatible con CDI, como _@ViewScoped_ o _@FlowScoped_. En este caso la clase del bean de controlador tendría este aspecto:

[source,java,indent=0]
----
	@ManagedBean(eager=true)
	@ApplicationScoped
	public class GlobalBean {
		@PostConstruct
		public void applicationStartup() {
			// carga inicial
		}
	}
----

* CDI: De momento CDI no proporciona una solución concreta para la carga de un bean asociado a un evento de inicio de aplicación, ni siquiera en su última versión 1.1, la incluida con Java EE 7. Es previsible que en el futuro se extienda la anotación _@Startup_ de EJB a cualquier bean de CDI con el nuevo stack Java EE 8. Actualmente, si lo necesitaramos, podríamos implementar nosotros mismos una extensión de CDI para obtener cargas iniciales usando la técnica que se explica en http://ovaraksin.blogspot.com.es/2013/02/eager-cdi-beans.html[este enlace].

Bien, como vemos, técnica y conceptualmente, en nuestro caso, lo más acertado es usar un bean singleton. Vamos a ello. Abrimos a Eclipse, hacemos botón derecho sobre la carpeta negocio y elegimos la opción _New > Other... > EJB > Session Bean_. En la pantalla de configuración del bean introducimos los valores que se indican en la figura y pulsamos el botón _Finish_:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig062.png[]

Para este bean singleton usamos además, como se ve en la figura, otra nueva característica de Java EE 6, No-interface View, a través de la anotación _@LocalBean_, que permite evitar la creación de una interfaz local o remota para nuestro bean. Como nuestra aplicación se va a ejecutar en una sola máquina virtual simplificamos nuestro diseño prescindiendo de las interfaces.

Seguimos con la implementación de nuestro bean CargaInicialDatos:

* Añadimos la anotación _@Startup_ a la clase.

* Añadimos el atributo de clase _em_ para inyectar el entity manager:

[source,java,indent=0]
----
    @PersistenceContext(unitName = "datosdrones")
    private EntityManager em;
----
    
* Y finalmente añadimos el método para la carga inicial de datos anotado con _@PostConstruct_, quedándo el código de la clase así:

[source,java]
----
package com.lametaweb.jdrone.negocio;

import java.util.Date;
import java.util.GregorianCalendar;
import javax.annotation.PostConstruct;
import javax.ejb.LocalBean;
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import com.lametaweb.jdrone.persistencia.Drone;
import com.lametaweb.jdrone.persistencia.PuntoRuta;
import com.lametaweb.jdrone.persistencia.Trabajo;

/**
 * Session Bean implementation class CargaInicialDatos
 */
@Singleton
@Startup
@LocalBean
public class CargaInicialDatos {

    /**
     * Default constructor. 
     */
	
    @PersistenceContext(unitName = "datosdrones")
    private EntityManager em;
    
    public CargaInicialDatos() {
        // TODO Auto-generated constructor stub
    }
    
@PostConstruct
public void cargaDeDatos(){
    	
    	// Puntos de Ruta
	PuntoRuta pr01tr01dr01 = new PuntoRuta();
	PuntoRuta pr02tr01dr01 = new PuntoRuta();
	PuntoRuta pr03tr01dr01 = new PuntoRuta();
	PuntoRuta pr04tr01dr01 = new PuntoRuta();
	PuntoRuta pr05tr01dr01 = new PuntoRuta();

	// Datos Puntos de Ruta
	pr01tr01dr01.setLatitud(37.367873f);
	pr01tr01dr01.setLongitud(-6.003724f); 
	pr01tr01dr01.setAltitud(100.0f);
	pr02tr01dr01.setLatitud(37.374797f);
	pr02tr01dr01.setLongitud(-5.996119f);
	pr02tr01dr01.setAltitud(200.0f);
	pr03tr01dr01.setLatitud(37.3726373f);
	pr03tr01dr01.setLongitud(-5.995503f);
	pr03tr01dr01.setAltitud(300.0f);
	pr04tr01dr01.setLatitud(37.367873f);
	pr04tr01dr01.setLongitud(-6.003724f);
	pr04tr01dr01.setAltitud(100.0f);
	pr05tr01dr01.setLatitud(37.367873f);
	pr05tr01dr01.setLongitud(-6.003724f);
	pr05tr01dr01.setAltitud(0.0f);

	GregorianCalendar gc = new GregorianCalendar();
	// hora inicio adelantando una hora
	gc.add(GregorianCalendar.HOUR, -1);
	Date fechaHoraInicio = gc.getTime();
	// hora finalización atrasando una hora
	gc.add(GregorianCalendar.HOUR, 2);
	Date fechaHoraFinalizacion = gc.getTime();
		
	Trabajo tr01dr01 = new Trabajo();
	tr01dr01.setNumeroDeRegistro("TR01DR01");
	tr01dr01.setVelocidad(10f);
	tr01dr01.setDescripcion("Reconocimiento de zona a baja cota.");
	tr01dr01.setFechaHoraInicio(fechaHoraInicio);
	tr01dr01.setFechaHoraFinalizacion(fechaHoraFinalizacion);
		
	tr01dr01.getPuntosDeRuta().add(pr01tr01dr01);
	tr01dr01.getPuntosDeRuta().add(pr02tr01dr01);
	tr01dr01.getPuntosDeRuta().add(pr03tr01dr01);
	tr01dr01.getPuntosDeRuta().add(pr04tr01dr01);
	tr01dr01.getPuntosDeRuta().add(pr05tr01dr01);
		
	Drone dr01 = new Drone();
	dr01.setNumeroDeSerie("FJHCAM01001");
	dr01.setModelo("Observer II");
	dr01.setPesoMaximoDespegue(1500);
	dr01.setAutonomia(25);
	dr01.setNumMotores(6);
	em.persist(dr01);
		
	tr01dr01.setDroneAsignado(dr01);
	em.persist(tr01dr01);
		
	dr01.getTrabajosAsignados().add(tr01dr01);
	em.merge(dr01);
    	
    } 
}
----

Antes de analizar el código de este método veamos una introducción exprés a JPA. 

En JPA el objeto central es el EntityManager. A través de los métodos de este objeto llevaremos a cabo las operaciones de persistencia que necesitemos. Los datos asociados a estas operaciones de persistencia serán jerarquías de las entidades persistentes, Drone, Trabajo y PuntoRuta, y deberemos gestionarlos dentro de una zona de memoria llamada contexto de persistencia cuya configuración se encuentra en el fichero persistence.xml.

Las operaciones de persistencia que más usaremos serán: persist, merge, remove, detach y find, que corresponden a las operaciones de alta, modificación, baja y consulta, respectivamenete, conocidas por sus iniciales en inglés CRUD (Create,
Read o Retrieve, Update y Delete). Por otra parte una entidad persistente, como por ejemplo Drone puede existir sólo en cuatro estados: new, managed, detached y removed.

El objeto EntityManager es usado desde la capa de negocio, donde se sitúa el bean para la carga inicial de datos CargaInicialDatos y el bean que veremos en el próximo post para la implementación del caso de uso de nuestra aplicación. Como ya sabemos nuestra capa de negocio usa la tecnología EJB. En un bean EJB puedo inyectar directamente un contexto de persistencia gestionado por el contenedor y si además uso la tecnología JTA la gestion de las transacciones será automática de modo que dentro de una transacción accederé por inyección siempre al mismo entitymanager, y el éste será destruido cuando la transacción finalice. Así que usando EJB y JTA me puedo centrar totalmente en las operaciones de negocio abstrayéndome de los detalles técnicos.

Vamos con nuestro código de carga inicial de datos. En resumen, da de alta en la base de datos un Trabajo con una ruta determinada y un Drone que es el que se configura para realizar ese trabajo. Podeis ver que sólo necesito manejar objetos de la capa de datos, quedando los detalles de la base de datos ocultos por la tecnología JPA. Veamos  un poco más en detalle el código desde el principio. Es conveniente que tengáis delante el diagrama de diseño que vimos en el post anterior para entender más facilmente el código:

* En una carga de datos nuestro objetivo es dar de alta una serie de datos en la base de datos. En JPA para dar de alta información tengo que crear la jerarquía de objetos que queremos dar de alta, dar valor a los atributos y establecer las relaciones entre ellos. Los nuevos objetos tienen un estado new en el cual aún no están dentro del contexto de persistencia.

* Creamos y seteamos los beans PuntoRuta de la ruta para el trabajo. Se define una ruta triangular cerrada siendo el punto inicial y final por tanto el mismo. Podéis verla en la siguiente figura:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig063.png[]

* A continuación se crea el objeto Trabajo y se inicializan sus atributos. Para el intervalo de comienzo y finalización del trabajo se calcula una hora hacia atrás y una hacia delante respecto del momento en que iniciamos la aplicación. Esto lo hago simplemente para que en la aplicación se muestre este drone introduciendo una fecha y hora que correspondan aproximadamente a la fecha y hora de ese momento.

* Los objetos PuntoRuta son añadidos a la colección que implementa la relación uno a mucho entre Trabajo y PuntoRuta.

* Creamos el objeto Drone y seteamos los atributos. En este punto el contexto de persistencia está aún vacío.

* Queremos guardar dos objetos independientes, Trabajo y Drone, donde existe una asocicación bidireccional y uno de ellos, Trabajo, se relaciona con N objetos dependientes PuntoRuta. Entendemos independientes como que no hay una relación todo/parte y por tanto su persistencia se debe gestionar de forma independiente. Tendremos por tanto que persistir por separado los dos objetos y luego establecer la relación en el sentido desde el primero al segundo. Esto es así porque lógicamente no puedo persistir un objeto que tenga una referencia a otro en estado new e independiente de él. Para los beans PuntoRuta no ocurre igual como veremos en un momento. 

* Persistimos primero por ejemplo el objeto Drone, usando el método _persist_ del entity manager. Ahora podemos ya establecer la relación muchos a uno en Trabajo entre Trabajo y Drone (que ya está en estado persistido) y persistir el objeto Trabajo.

* Existe una relación de composición entre Trabajo y PuntoRuta y por tanto cuando persistamos un trabajo se deben persistir los puntos de ruta asociados. Esto se implementa con el atributo cascade de la anotación @OneToMany `@OneToMany (cascade = CascadeType.ALL)`.

* Finalmente establecemos la relación uno a muchos entre Drone y Trabajo y la persistimos. Aquí no uso persist porque el objeto implicado, Drone, ya está en estado persistido.

* Todas estas operaciones de persistencia se engloban en una transacción que comienza y acaba al mismo tiempo que el método cargaDeDatos. Es algo que se gestiona de forma automática por el servidor a través de la tecnología JTA.

Y esto es todo. Como podeis ver no tiene precio el poder abstraerse de la base de datos y hacerlo todo conociendo simplemente los fundamentos de JPA. Para afianzar los conceptos os explico rapidamente esos fundamentos de JPA.







TODO: Ver qué pasa si hay cascade desde drone a trabajo.