= Desarrollo de una aplicación desde cero. Diseño e implementación de la capa de persistencia.
La metaweb
:hp-tags: JPA, Hibernate, persistencia, diagrama de clases
:published_at: 2015-06-08


Continuamos con la implementación de la aplicación. Construiremos la aplicación desde la capa de persistencia hacia arriba hasta la capa de presentación, que es el modo habitual para los desarrollos Java EE por capas.

== Introducción

La capa de persistencia tiene como cometido establecer un mapeo con la base de datos para las entidades persistentes del modelo de dominio de manera que podamos manipular la información a través de una jerarquía de objetos Java y nos abstraiga totalmente de los detalles de la base de datos. El modelo de dominio es un documento de la fase de análisis del proyecto que consiste en una serie de diagramas de clase donde se determinan las entidades relevantes para nuestro proyecto, la información contenida en cada una y las relaciones entre ellas. 

En el plano tecnológico tenemos que definir lo siguiente:

* El proveedor de persistencia: Es el conjunto de librerías que implementan el ORM. Elegimos Hibernate, ya que es el más extendido y además viene de serie en nuestro servidor JBoss.

* El gestor de base de datos: Usamos una base de datos Derby embebida lo que nos permite simplificar de momento la capa de Datos del proyecto evitando la necesidad de instalar un servidor de base de datos, ya que el gestor de base de datos está contenido en este caso en un archivo jar, junto con el driver. Por otro lado con Derby podemos tener el esquema de la base de datos, es decir donde residen las tablas, en memoria o en el disco duro, nosotros elegimos esta última opción para tener la posibilidad de explorar los elementos que hibernate generará de forma automática. No he querido usar la base de datos H2, que trae puesta el servidor JBoss EAP, similar a la base de datos Derby, para que veamos también como desplegar recursos en el servidor desde Maven.

¿Y qué elementos tenemos que añadir a la capa de persistencia? Pues por un lado un fichero de configuración, donde definimos todo lo relevante, y que leerá Hibernate, y por otro las clases del mapeo objeto relacional, basadas en la tecnología JPA, y que eran tres: Drone, Trabajo y PuntoRuta. Y no hay más, mucho más simple y limpio que en versiones pasadas de EJB.

== La configuración

Vamos primero con el fichero de configuración. El fichero de configuración de la unidad de persitencia es _persistence.xml_. La especificación JPA2 (JSR-338) permite desplegar clases de persistencia fuera de un empaquetado JAR, directamente dentro del WAR de nuestra aplicación. En este caso se indica que el fichero persistence.xml debe situarse en la carpeta _WEB-INF/classes/META-INF/_ . Por lo tanto, y con arreglo a la configuración por defecto de Maven para los ficheros de recursos, en nuestro proyecto tendremos que crear el fichero en la carpeta _src\main\resources\META-INF\_. Creamos el fichero en la opción de menú _New > Other... > XML > XML File_.


.Fichero de configuración de persistencia
[cols="1h,5", width="70%"]
|===
|Nombre 
|persistence.xml 

|Ruta
|jdrone/src/main/resources/META-INF/
|===

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig040.png[]

Copiamos el siguiente contenido en el fichero persistence.xml:

[source,xml,indent=0]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<persistence xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd" version="2.0">
		<persistence-unit name="datosdrones" transaction-type="JTA">
			<jta-data-source>java:jboss/datasources/DerbyDS</jta-data-source>
			<exclude-unlisted-classes>false</exclude-unlisted-classes>
			<properties>
				<property name="hibernate.dialect" value="org.hibernate.dialect.DerbyDialect" />
				<property name="hibernate.hbm2ddl.auto" value="create-drop" />
			</properties>
		</persistence-unit>
	</persistence>
----

Veamos el significado de cada elemento:

* La primera línea indica que se trata de un fichero XML.
* *<persistence>*: Es el elemento raíz y declara los diferentes espacios de nombres que contienen las reglas de escritura del documento y
además indica la versión JPA que hemos adoptado, en este caso la 2.0, que es la que correspende a Java EE 6. Dentro del elemento raíz
 podemos definir varias de unidades de persistencia. Nosotros queremos mapear nuestros objetos en un único
lugar de un mismo modo por lo que necesitamos una única unidad.
* *<persistence-unit>*: El siguiente elemento describe la unidad de persistencia, que es el mecanismo que genera el contexto de persistencia donde
 residen nuestros beans persistentes. El atributo name lo usaremos para referirnos a ella desde el código. Por otro lado el atributo
	transaction-type provee la provee de la tecnología JTA para la gestión automática de las transacciones.
* *<jta-data-source>*: Define el nombre JNDI del origen de datos que es el recurso de servidor a través del cual nuestra aplicación accede
	a la base de datos. Más adelante veremos como instalarlo. EL nombre JNDI seguirá el formato java:jboss/datasources/<nombre_origen_datos>.
* *<exclude-unlisted-classes>*: Evita tener que nombrar aquí las clases del contexto estableciendo que todas las clases anotadas como entidades
	pertenerán a este contexto de persistencia.
* *<properties>*: Las propiedades adicionales las necesita el proveedor de peristencia elegido, en nuestro caso Hibernate, que recordemos que es
	el que ya trae integrado el servidor JBoss. Tenemos dos propiedades definidas:
	** La propiedad _hibernate.dialect_ de indica al proveedor que nuestra base de datos será Derby.
	** La propiedad _hibernate.hbm2ddl.auto_ indica al proveedor que genere los elementos del esquema de la base de datos de forma automática
		a partir de la información de las entidades persistentes de nuestro código fuente. Recordad que nosotros tendremos tres.

NOTE: Si usamos Hibernate como proveedor de persistencia en JBoss, que es lo habitual, podemos obviar el elemento
<provider>org.hibernate.ejb.HibernatePersistence</provider> en el fichero persistence.xml.

Antes de escribir el fuente de las clases tenemos que añadir al proyecto la información de dependencias para Hibernate. Primero añadimos este fragmento XML bajo el elemento <project> del archivo pom.xml:

[source,xml,indent=0]
----
	<dependencyManagement>
		<dependencies>
			<!-- Define the version of JBoss' Java EE 6 APIs we want to import. 
				Any dependencies from org.jboss.spec will have their version defined by this 
				BOM -->
			<!-- JBoss distributes a complete set of Java EE 6 APIs including a 
				Bill of Materials (BOM). A BOM specifies the versions of a "stack" (or a 
				collection) of artifacts. We use this here so that we always get the correct 
				versions of artifacts. Here we use the jboss-javaee-6.0-with-tools stack 
				(you can read this as the JBoss stack of the Java EE 6 APIs, with some extras 
				tools for your project, such as Arquillian for testing) and the jboss-javaee-6.0-with-hibernate 
				stack you can read this as the JBoss stack of the Java EE 6 APIs, with extras 
				from the Hibernate family of projects) -->
			<dependency>
				<groupId>org.jboss.bom</groupId>
				<artifactId>jboss-javaee-6.0-with-tools</artifactId>
				<version>${version.jboss.bom.eap}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>										
		</dependencies>
	</dependencyManagement>
----

Se trata de información proporcionada por JBoss que resuelve automáticamente las versiones de nuestras dependencias.

Y a continuación, también bajo el elemento <project>, añadimos las dependencias en sí:

[source,xml,indent=0]
----
	<dependencies>
		<dependency>
			<groupId>org.hibernate.javax.persistence</groupId>
			<artifactId>hibernate-jpa-2.0-api</artifactId>
			<scope>provided</scope>
		</dependency
		<dependency>
			<groupId>org.jboss.spec.javax.annotation</groupId>
			<artifactId>jboss-annotations-api_1.1_spec</artifactId>
			<scope>provided</scope>
		</dependency>							
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<scope>provided</scope>
		</dependency>
	</dependencies>
----

Es posible que el archivo pom.xml se nos abra en Eclipse como un formulario. Para mostrarlo en adelante como un fichero XML pulsamos con el botón derecho sobre el fichero y seleccionamos la opción _Open With > JBoss Tools XML Editor_ como se indica en la siguiente figura:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig047.png[]

Añadimos además un par de propiedades al fichero POM. Copiamos y pegamos bajo el elemento <project> lo siguiente:

[source,xml,indent=0]
----
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<version.jboss.bom.eap>1.0.0.CR1</version.jboss.bom.eap>
	</properties> 
----

La primera propiedad fija la codificación usada por el compilador y otros plugins a UTF-8 y la segunda representa una variable. 

Las propiedades tienen dos usos:
. Para definir una variable que es usada en uno o más puntos del documento.
. Para asignar un valor a un elemento del documento, por ejemplo la línea
<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> equivale a añadir el elemento <sourceEncoding> bajo el elemento <build> así:

[source,xml,indent=0]
----
	<project>
		...
		<build>
			...
			<sourceEncoding>UTF-8</sourceEncoding>
----

== Diseño de entidades persistentes

Vamos con las clases de persistencia. Tendremos tres clases: Drone, Trabajo y PuntoRuta. Cada clase será básicamente un POJO (Plain Java Object)
con anotaciones con la información del mapeo de persistencia para los atributos de la propia entidad y las relaciones con
el resto de entidades.

A partir de la etapa de análisis la información que se asignará a cada entidad será la siguiente:

.Atributos definidos en las clases de persistencia
[cols="1,2", width="70%"]
|===
.5+|*Drone* 
|numeroDeSerie
|modelo
|autonomia
|numMotores
|pesoMaximoDespegue
		
.5+|*Trabajo*
|numeroDeRegistro
|fechaHoraDeInicio
|fechaHoraDeFinalizacion
|velocidad
|descripcion
		
.3+|*PuntoRuta*
|latitud
|longitud
|altitud
|===

Además todas las entidades tendrán un atributo adicional que actúa como clave única a través del cual implementaremos las relaciones entre las entidades.

Las relaciones las deducimos de los requisitos tomados antes en la etapa de análisis:

* Un Trabajo se asigna a un único Drone de entre los Drones disponibles en la fecha del trabajo.
* Un Drone tiene ninguno, uno o varios trabajos programados.
* Un Trabajo se compone de un recorrido formado por dos o más puntos de ruta.
	
Con toda esta información podemos ya elaborar el diagrama de clases que establece el diseño de nuestras clases de persistencia.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig045.png[]

La clase en la parte superior del diagrama corresponde a la capa de negocio y la implementaremos más adelante. El resto constituye la capa de persistencia.

NOTE: Otro planteamiento a la hora de implementar la capa de persistencia es crear primero el esquema de la base de datos y a partir de él, con un asistente, generar un código fuente inicial para las clases persistentes, al que luego añadiremos información adicional en forma de anotaciones para definir distintos aspectos relacionados con el mapeo.

== Implementación de entidades persistentes

Bien, vamos con la implementación. Creamos las tres clases primero y no una a una para evitar errores por referencias a clases inexistentes. Añadimos cada clase haciendo click en botón derecho sobre la carpeta _/src/main/java/_ y _New > Class_. Si la opción del menú no está visible ir a la opción _Java > Class_ después de hacer _New > Other..._.

.Datos para creación de clases de persistencia
[cols="1h,5"]
|===
|Nombres 
|Drone, Trabajo, PuntoRuta

|Paquetes
|paquete idem para las tres: com.lametaweb.jdrone.persistencia
|===

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig050.png[]

Por orden, escribiremos primero las variables correspondientes a los atributos en las tres entidades y sus anotaciones de persistencia, y a continuación escribiremos las variables y anotaciones para las relaciones entre las entidades. Tomamos como referencia y guía el diagrama de clases anterir de la fase de diseño.

=== Entidad Trabajo

Para la entidad Trabajo nos vamos a la clase correspondiente y añadimos los cinco atributos definidos en el diagrama. Para implementar el identificador único podemos optar por la estrategia de ID Natural, que consiste en tomar como ID de la entidad un subconjunto de los atributos de la misma, o bien por la estrategia de ID Generado, que en general es más aconsejable, dado que en el primer caso la eficiencia en las consultas es menor y además podemos tener problemas si el significado de los campos escogidos cambia en el tiempo. 
Un ID Generado podemos implementarlo añadiendo un atributo adicional de tipo numérico a la clase. 

Copiamos y pegamos el siguiente fragmento de código en de la clase:

[source,java,indent=0]
----
private Integer idTrabajo;
private String numeroDeRegistro;
private Date fechaHoraDeInicio;
private Date fechaHoraFinalizacion;
private Float velocidad;
private String descripcion;
----

Y pulsamos la combinación de teclas o hotkey ctrl+shift+O para traernos las importaciones necesarias. En este caso se da una 
ambigüedad porque hay dos clases Dates en paquetes diferentes, nosotros tenemos que elegir el paquete java.util.Date.
 
Generamos ahora los métodos de acceso a estos atributos, con botón derecho sobre la clase y _> Source > Generate Getters and Setters_, Seleccionar todos los atributos y pulsar OK. Dejamos el código fuente ordenado con botón derecho _> Source > Format_. Finalmente guardamos la clase pulsando el icono del disquette o usando la hotkey Ctrl + S.
 
A nivel de clase hacemos los siguientes cambios: 

Convertimos la clase en serializable. Esto es una buena práctica en general porque en ciertas situaciones es necesario que el bean sea serializable.
Podéis consultar http://www.adam-bien.com/roller/abien/entry/do_jpa_entities_have_to[este link] para más información.

[source,java,indent=0]
----
	public class Trabajo implements Serializable{
----

Aparecerá un warning que solucionamos añadiendo la línea `private static final long serialVersionUID = 1L;` justo antes de los atributos de la clase.
Esta constante se utiliza para cotejar versiones en clases que se serializan explícitamente.

Y añadimos la anotación `@Entity` encima de la delcaración de la clase para que sea tratada como un bean JPA persistente.

[source,java,indent=0]
----
	@Entity
	public class Trabajo implements Serializable{
----

A nivel de atributos añadimos las siguientes anotaciones de persistencia:

* idTrabajo:

	** `@Id`: Indica que este campo va a ser el identificador único de la entidad persistente. En la base de datos se mapeará como la clave primaria.
	** `@GeneratedValue(strategy=GenerationType.SEQUENCE)`: Establece la estrategia de generación de valores únicos.
		Aquí hay dos alternativas, podemos generar nosotros mismos los valores o delegar en JPA para que la generación tenga lugar
		en la base de datos, en general se delega en JPA. Y dentro de estra opción 
		existen tres posibilidades
		IDENTITY, SEQUENCE y TABLE. Optamos por SEQUENCE ya que los otros dos métodos son menos convenientes. Puedes ver una explicación más
		detallada http://en.wikibooks.org/wiki/Java_Persistence/Identity_and_Sequencing[aquí].
Como siempre pulsamos Ctrl + Shift + O para importar las clases necesarias.

* numeroDeRegistro:
	** @Basic(optional = false): Indica que el valor de este atributo no puede ser nulo cuando la entidad se persista. Es decir que
	obligamos a que los trabajos guardados en la base de datos tengan su número de registro.

* fechaHoraDeInicio y fechaHoraFinalizacion:
	** @Basic(optional = false)
	** @Temporal(TemporalType.TIMESTAMP): Es necesaria en campos de tipo fecha para especificar si es un campo que indica una fecha, una hora,
		o ambos. En nuestro caso guardamos fecha y hora.

* velocidad:
	** @Basic(optional = false)	

* descripcion:
	** @Lob: Ya que preveemos por lo indicado por el cliente que este campo albergará textos de gran tamaño y no tendremos suficiente con
		un tipo de datos Basic.
    ** @Size(max = 65535): Mapeamos este campo con un CLOB, con un tamaño de 64Kb. Lo hacemos así porque se prevé que
		la longitud de esta información textual sea mayor que los 32Kb que soporta el tipo VARCHAR generado para un tipo Basic String.
		
Como práctica haced vosotros lo mismo para las dos clases restantes. Es todo análogo excepto algún detalle que os comento.

=== Entidad Drone

Añadimos los atributos y el identificador `idDrone` y generamos los métodos getters y setters.

[source,java,indent=0]
----
	private Integer idDrone;
	private String numeroDeSerie;	// es un valor obligatorio
	private String modelo;
	private Integer autonomia;
	private Integer numMotores;		// debe estar en el intervalo cerrado [4,8]
	private Integer pesoMaximoDespegue;
----

El resto es todo análogo a lo realizado con la entidad Trabajo exceptuando los dos detalles que se indican en los comentarios junto a los atributos. Para el atributo numeroDeSerie, como antes, añadimos la anotación `@Basic(optional = false)` y para el rango numérico en el atributo numMotores usamos la anotación, `@Range(min = 4, max = 8)`. Y eso es todo.

Sin embargo como ya hebréis advertido surge un pequeño problema, cuando pulsamos la combinación de teclas Ctrl + Shift + O para traernos los imports nos damos cuenta de que Eclipse no es capaz de localizar el paquete para la anotación @Range. El motivo es que se trata de una anotación especifica del proveedor de persistencia, Hibernate, y que queda fuera por tanto del estándar JPA. Así que nos toca añadir otra dependencia a nuestro fichero pom.xml.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig055.png[]



