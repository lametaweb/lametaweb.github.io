= Desarrollo de una aplicación desde cero. Definición y creación del proyecto.
La metaweb
:hp-tags: Modelo de Dominio, Maven, Eclipse, Java EE, desde cero
:published_at: 2015-06-01

En los dos Posts anteriores dejamos listo un banco de trabajo sobre el que encarar el desarrollo de cualquier aplicación web basada en Java EE. En este y sucesivos Posts recorreremos un camino que nos llevará hasta la creación de una aplicación Java EE básica sobre la que podremos experimentar a nuestro antojo con técnicas, tecnologías y herramientas en la esfera de Java EE. Enfocaremos su desarrollo de manera pragmática, creando un proyecto desde cero y sin recurrir a ningún asistente. De este modo seremos realmente conscientes de cada elemento que compone la aplicación y de que ningún otro es necesario. En los proyectos reales al contrario, donde el objetivo es desarrollar de la manera más eficaz y eficiente, se utilizan diferentes tipos de herramientas integradas o no en Eclipse u otros IDEs. Algunas de ellas seguro que tendrán un merecido hueco en el este Blog en futuros Posts.

== Motivación de la aplicación

Lo que haremos es imaginar un cliente con una necesidad, analizarla para entenderla y finalmente darle respuesta en forma de aplicación. Haremos ahora un análisis a partir del que generaremos una documentación que será la base para la fase de implementación. La construcción de una webapp, por otro lado, no es un proceso lineal sino más bien cíclico, donde tendremos que ir trabajando sobre todas las fases, desde el análisis a la implementación, hasta el fin del ciclo de vida de la aplicación, porque 
a medida que vayamos entendiendo con mayor profundidad la realidad del cliente irán produciéndose ajustes que afectarán tanto al análisis, como al diseño, y a las tecnologías empleadas. La creación de una aplicación es similar al proceso de pintar un cuadro. El cuadro no se empieza por arriba y se acaba por abajo como lo haría la impresora que tenemos en casa sino que se va definiendo y perfilando en su conjunto, incluso en ocasiones descartando, añadiendo o cambiando elementos completos de la escena. En pintura el pintor dialoga consigo mismo al crear su obra, en el desarrollo del software debe existir un dialogo continuado y fluido entre quien
conoce qué necesita y quienes sabemos cómo construirlo.

Bien, imaginemos un cliente que posee una empresa de trabajos aéreos, TAS, con un parque de drones autónomos capaces de llevar a cabo diferentes tareas, desde vigilancia nocturna a control de plagas. La empresa arrancó hace solo un año, con un par de aparatos, y un sólo cliente, pero su actividad ha tenido un crecimiento progresivo y bien gestionado y en la actualidad su parque de aeronaves se ha incrementado hasta 20 drones con diferentes características. Este aumento de actividad ha traido también consigo un aumento de la dificultad en la gestión de los activos de la compañía. Por eso el gerente cree necesario apoyar los trabajos en un software que facilite la realización de tareas que se repiten en el tiempo y nos ha llamado para que le planteemos una solución.

== Análisis inicial

Tras varias reuniones con los empleados designados como interlocutores para el proyecto detectamos estas carencias:

1. Dificultad en la planificación de trabajos: El Gerente no conoce la disponibilidad de aparatos para una fecha y no puede dar a sus clientes fechas de comienzo del trabajo con agilidad.
2. Carencia de datos sobre trabajos ya realizados: El Jefe Técnico no dispone de información sobre trabajos ya realizados, útiles cuando éstos han de repetirse o cuando se inician trabajos similares.
3. Desconocimiento del progreso de cada trabajo: El Jefe de Operación no puede informar de forma clara al cliente en cada momento del progreso del trabajo encargado.
4. Ausencia de información estadística: Variaciones de carga de trabajo estacionales, frecuencia de averías por componentes y por modelo de drone, etc.

Lo anterior naturalmente no es un análisis de requisitos exhaustivo, pero muestra cómo una aplicación puede facilitar en gran medida las tareas dentro de una organicación. Cómo nuestro objetivo ahora es entender las partes de una aplicación Java EE tomaremos en cuenta sólo el primer punto de la lista.

Delimitamos primero el sistema a desarrollar. Como entidades del modelo de dominio distinguimos las siguientes:

* Drone: Dispositivo mecánico que tiene una serie de trabajos programados.

* Trabajo: Tarea de un drone que se extiende en el tiempo desde un momento inicial a otro final estimados y que consiste en la realización de un recorrido con un punto inicial, o despegue, N puntos intermedios, y un punto final, o aterrizaje, geolocalizados.

* PuntoRuta: Representa un punto geolocalizado que forma parte de la ruta que se define para un Trabajo.

El primer requisito genera un caso de uso, donde el usuario introduce una fecha y hora y solicita un listado de los drones que están realizando un trabajo en esa fecha y hora. La interfaz de usuario necesaria será por tanto una única pantalla con un componente para la entrada de una fecha y un área para mostrar el listado de los drones. Para cerrar esta "minifase" de analisis sólo nos falta ponerle el nombre al proyecto, y sin tirar de demasiada imaginación lo bautizamos con el nombre de jDrone.

A continuación establecemos la arquitectura de la aplicación, que es de lo que se trata realmente en este Post. Haciendo una lista de todos los elementos tecnológicos implicados tenemos:

* Entorno de desarrollo (IDE): Eclipse con conjunto el de plugins de JBoss.
* Gestor de ciclo de vida: Maven .Que viene ya incluido e integrado con el IDE.
* Gestor de versiones del código fuente: Git con repositorio remoto en GitHub. Este aspecto se tratará cuando ya tengamos la versión 1.0 de la aplicación lista de manera que las ampliaciones posteriores a esta versiones estén ya versionadas.
* Empaquetado de la aplicación: WAR.
* Servidor: JBoss EAP 6. Certificado para Java EE 6.
* Framework de capa de presentación: JSF 2.1.
* Framework de capa de negocio: EJB 3.1.
* Gestión de beans: CDI 1.1.
* Framework de persistencia: JPA 2.1 implementado con Hibernate.
* Base de datos: Derby embebida en la aplicación con base de datos en el disco duro (no en memoria).

== Ajuste del entorno

Muy bien, manos a la obra, primero haremos algunos ajuste a nuestro recien estrenado entorno de desarrollo. Añadimos el siguiente elemento `<profile>` al fichero de configuración de Maven a nivel de usuario, localizado en una ruta del tipo _C:\Users\Usuario\.m2\settings.xml_, para que nuestro IDE pueda descargar las dependencias específicas de JBoss que vamos a usar en el proyecto.

[source,xml,indent=0]
----
<?xml version="1.0" encoding="UTF-8"?>
<settings>
  <profiles>
    <profile>
      <id>jboss-public-repository</id>
      <repositories>
        <repository>
          <id>jboss-public-repository-group</id>
          <name>JBoss Public Maven Repository Group</name>
          <url>https://repository.jboss.org/nexus/content/groups/public-jboss/</url>
          <layout>default</layout>
          <releases>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
          </releases>
          <snapshots>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
          </snapshots>
        </repository>
      </repositories>
      <pluginRepositories>
        <pluginRepository>
          <id>jboss-public-repository-group</id>
          <name>JBoss Public Maven Repository Group</name>
          <url>https://repository.jboss.org/nexus/content/groups/public-jboss/</url>
          <layout>default</layout>
          <releases>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
          </releases>
          <snapshots>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
          </snapshots>
        </pluginRepository>
      </pluginRepositories>
    </profile>
  </profiles>
  <activeProfiles>
    <activeProfile>jboss-public-repository</activeProfile>
  </activeProfiles>
</settings>
----

Por otro lado, para que en la carpeta de nuestro workspace no se generen ficheros de índice de gran tamaño nos vamos a Eclipse a la opción del menú _Window > Preferences > Maven_ y dejamos las opciones tal como se indican en la figura.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig005.png[]

Además podemos buscar en esta carpeta los ficheros con la extensión _.cfs_ y borrar los que sean de gran tamaño.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig010.png[]

Adicionalmente disponemos de una View de Eclipse donde podemos visualizar los repositorios que tenemos configurados y tocar la configuración sobre los índices que queremos descargar para cada uno de ellos.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig015.png[]

OK, nos vamos a Eclipse y elegimos como espacio de trabajo la carpeta que creamos para tal fin, similar a _C:\TALLER\workspace\_. Si es la primera vez
que entramos en el workspace pulsamos el botón Workbench en la esquina superior derecha de la pantalla de bienvenida para retirarla, desmarcamos el check _Show on Startup_ en la ventana de JBoss Central que aparece en el centro del IDE y la cerramos. Finalmente maximizamos la ventana de Eclipse para trabajar con el mayor espacio posible.

Antes de crear cualquier elemento de la aplicación definimos la codificación que Eclipse empleará en los ficheros del proyecto. Esta cuestión
es importante ya que evita que tengamos problemas con los caracteres mostrados que estén fuera del estándar ASCII. Para ello nos vamos al menú
_Window > Preferences > General > Workspace > Text File Encoding > Other > UTF-8_ y en esa misma ventana desmarcamos la opción _Build automatically_.

NOTE: Si no lo hemos hecho aún es conveniente quitar el revisor de sintaxis de Eclipse. Ir a _Window > Preferences > General > Editors > Text Editors > Spelling_  y desmarcar _Enable Spell Checking_. Así podremos distinguir mejor los errores y los warnings que aparezcan en nuestro código fuente durante el desarrollo.

== Entrando en materia. Creación del proyecto.
	
Creamos un proyecto Maven en blanco en la opción _File > New > Maven Project_. En la primera pantalla del wizard marcamos la primera opción
_Create a simple proyect (skip archetype selection)_ y pulsamos _Next_.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig020.png[]

Definimos las propiedades básicas del proyecto: Coordenadas en el repositorio Maven, empaquetado y datos descriptivos:

* GroupId : com.lametaweb.javaee
* ArtifactId : jdrone
* pakcaging : war
* Name : jDrone Lite
* Description : Proyecto Maven Java EE basico desde cero

Los demás campos los dejamos a su valor por defecto y pulsamos el botón _Finish_. Después de unos segundos el proyecto se habrá creado. Si abrimos
el nodo correspondiente al proyecto veremos que la estructura y ficheros es la que corresponde a un proyecto Maven. Para ver de forma
más limpia los elementos del proyecto abrimos la View _Navigator_. Esta vista nos muestra simplemente carpetas y ficheros, es decir lo que
constituye en proyecto Java EE sin más.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig025.png[]

Vamos a ver rapidamente el significado de cada elemento, pero antes fijamos la codificación del proyecto a nivel del propio proyecto, con esto evitamos que nuestra codificación dependa del IDE al que eventualmente llevemos el proyecto. Así que pulsamos botón derecho sobre el proyecto y Properties > Resource > Text File encoding > Other: UTF-8.

.Elementos generados en la creación del proyecto
[cols="1,3", options="header"]
|===

|Elemento 
|Descripción

|Carpeta _.settings_
|[small]#Es generada por el propio Eclipse para guardar información de configuración del proyecto. No es parte constituyente de nuestro proyecto ya que es creada para gestión interna del IDE.# 

|Carpeta _src_
|[small]#Aquí situaremos todos los elementos de nuestro proyecto organizados en carpetas según las convenciones adoptadas por Maven. En la subcarpeta _main_ están los elementos necesarios para generar la aplicación y en la carpeta _test_ los elementos para las pruebas unitarias.#

|Carpeta _target_
|[small]#Contendrá los productos generados a partir de los elementos de la carpeta _src_. En este caso será un fichero desplegable _.war_ conteniendo nuestra aplicación que incluirá toda la información para su despliegue en el servidor.#

|Fichero _.classpath_
|[small]#Generado por Eclipse para registrar los lugares donde buscar clases java.#

|Carpeta _src_
|[small]#x#

|Carpeta _src_
|[small]#x#

|===

