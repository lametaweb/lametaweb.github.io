= Implementación de un CRUD: La pantalla de Gestión de Trabajos.
La metaweb
:hp-tags: JSF, JavaServer Faces, CRUD, EJB, Hibernate, backing bean, Git, GitHub
:published_at: 2015-07-23

En este post os resumo los aspectos más relevantes de la implementación del caso de uso de introducción de Trabajos de Drones creado a partir de la solicitud de dicha funcionalidad por parte de nuestro cliente imaginario, TAS. La release de la que se parte es la 1.0.1, y a la que llegaremos será la 1.1.x. Así que usad la primera para intertar implementar la pantalla por vuestra cuenta y la segunda para ver la impleme tación terminada.

Yo aquí os haré una serie de comentarios sobre la release 1.1.x, señalando los detalles de implementación interesantes. Pero primero una breve introducción sobré qué es un mantenimiento de una entidad del modelo de dominio. En inglés se conoce como CRUD: Create, Read/Retrieve, Update, Delete, y se refiere al conjunto de elementos de diseño y programa necesarios para implementar el típico mantenimiento de una entidad. El caso más sencillo se da cuando la entidad es una entidad "hoja" en nuestro diagrama de clases. Si la entidad tiene una o más relaciones con otras entidades tendremos, en ocasiones, que mantenerlas también en el CRUD. Recordemos nuestro sencillo diagrama de clases:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig045.png[]

¿Qué mantenimientos podríamos hacer aquí? Bueno, en este caso tienen sentido dos mantenimientos. El que vamos a implementar, de la entidad Trabajo, donde tendremos que mantener la relación desde Trabajo hacia Drone, que representa la selección del drone que va a llevar a cabo el trabajo, y la relación del trabajo con sus puntos de ruta, que representa la ruta que seguirá el drone en ese trabajo. Y por otro lado también cabe realizar un CRUD de la entidad Drone donde no cabe el mantenimiento de la relación desde Drone a Trabajo ya que cuando por ejemplo creamos un drone no tiene sentido en nuestro caso asignarle en el mismo caso o en otro diferente uno o más trabajos.

Centrándonos en el mantenimiento de la entidad Trabajo empecemos con su resolución. Por partes, hacemos primero un análisis, luego el diseño de la interfaz y por último vemos la implementación de cada capa.

La lista de requisitos extraida de la entrevista con el cliente es la siguiente:

.Lista de requisitos del mantenimiento de trabajos
[width="90%"]
|===
|[small]*Pantalla de listado de trabajos*
|[small]#Inicialmente se presentará un listado de trabajos en pantalla.#
|[small]#El listado se debe ordenar por todos sus campos y se presentará paginado.#
|[small]#Sobre el listado dispondremos de comandos para Editar, dar de baja y dar de baja definitiva un trabajo.#
|[small]#La baja definitiva debe ser confirmada.#
|[small]*Pantalla de mantenimiento de trabajo*
|[small]#Todos los campos se validarán presentando mensajes adecuados.#
|[small]#Se presentará un listado de los drones disponibles según la fecha del trabajo.#
|[small]#La ruta se importará desde un excel generado por la aplicación de gestión de mapas usada para la definición de rutas sobre mapa.#
|===

Posteriormente a la definición de los requisitos decidimos si usar o no una librería JSF específica que nos aporte capacidades adicionales en la capa de presentación. Nuestras pantallas usarán listados con capacidades de ordenación, paginación, etc. Además necesitamos acciones con confirmación. El coste de incluir la librería es muy bajo y finalmente optamos por incluir una en nuestro proyecto. Entre RichFaces y Primefaces elegimos la segunda por sus características en cuanto a número de componentes, curva de aprindizaje, documentación, comunidad y tendencia exponencial de incremento en el uso en nuevos proyectos.

NOTE: Si queréis comparar la popularidad de distintas tecnologías usad Google Trends. Tendréis que añadir los términos que identifiquen a cada tecnología. Y hay que cuidar que el término no recoja resultados no deseados. Por ejmeplo si queréis ver la tendencia del framework ionic para aplicaciones híbridas escribir "ionic framework" y no "ionic" a secas. La URL es https://www.google.es/trends[ésta]. 

Añadimos PrimeFaces al proyecto. Además, optamos por trabajar con la última versión de JSF. La versión que trae EAP 6.3 es la 2.1. Se ha intentado seguir el procedimiento existente en la web para incluir la última versión en este servidor pero no ha sido posible. En resumen el proceso pasa por bajar una aplicación Maven desde Github que genera un fichero CLI que realiza el deploy de los tres slots para los tres módulos que se ven afectados por la actualización. Sin embargo uno de los slots da problemas ya que parece que el script está actualizado para operar con las primeras versiones del servidor Wildfly.

De modo que se opta por instalar el nuevo servidor Wildfly en su última versión, la 9.0.1, y así tener disponible una plataforma Java EE 7 completa. Lo primero será descargar el fichero de instlación del servidor http://wildfly.org/downloads/[aquí]. Tenéis que elegir la primera de las opciones, la que tiene la versión 9.0.1.Final.

NOTE: Descargaos también los Quickstarts porque os van a venir muy bien como material de consulta en las etapas iniciales de la implementanción de un nuevo proyecto sea cual sea la naturaleza de éste.

Una vez instalado WildFly lo añadimos a Eclipse como nueva unidad de ejecución. La versión de las JBoss Tools sólo ofrecía un conector para la versión 8 del servidor pero después de las pruebas de arranque y parada parece que para un uso sencillo no tendremos problemas con esto.

¿Qué cambios tendremos que hacer en nuestro proyecto tras el cambio de servidor y la actualización de las versiones de las tecnologías? En primer lugar tendremos que adaptar las dependencias Maven a las del nuevo servidor, un proceso sin demasiada complicación. Para consultar los cambios en el código que se produzcan durante el desarrollo de este post  bajaos la release 1.1.x en https://github.com/lametaweb/jdrone/archive/1.1.0.zip[esta dirección].

Aprovechando que pom.xml ha variado he refactorizado el ciclo de construcción de modo que ahora existe un profile "despliegue-recursos" que se debe ejecutar la primera vez que despleguemos la aplicación o bien si los recursos has sido eliminados por cualquier motivo. Esto lo he hecho para evitar los problemas derivados del bloqueo de la base de datos. Tenéis que crear un nueva configuración de ejecución: Botón derecho proyecto > Rus As > Run Configurations... > botón derecho sobre Maven build > New > En la entrada Goals escribir "clean install -Pdespliegue-recursos" y dar un nombre al nuevo perfil.

En segundo lugar, como vamos a subir desde JSF 2.1 a 2.2 actualizamos los espacios de nombres en el nodo raiz del fichero _faces-config.xml_. Además tendremos que actualizar la faceta JavaServer Faces. La desmarcamos, esperamos a que se desinstale y la volvemos a marcar. Al añadirla de nuevo la opción _JSF Implementation Library_ dejadla así _Type > Disable Library Configuration_.

Para comprobar que JSF 2.2 funciona correctamente modificamos nuestra página index.xhtml para adaptarla a HTML5 y JSF 2.2, añadiendo además una etiqueta nueva en la versión 2.2.

Para la adaptación a HTML 5:

`<!DOCTYPE html>`

Para la adaptación a JSF 2.2 cambiamos los espacios de nombres:

`<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:h="http://xmlns.jcp.org/jsf/html"
	xmlns:f="http://xmlns.jcp.org/jsf/core">`

Finalmente sustituimos:

`<f:event listener="#{disponibilidadBean.listaEstadoDronesPorFecha()}" type="preRenderView" />`

por:

`<f:viewAction action="#{disponibilidadBean.listaEstadoDronesPorFecha()}" onPostback="true"></f:viewAction>`

Además ahora no se admitirán los típicos caracteres de espaciado `\&nbsp;` y tendremos que sustituirlos por el equivalente código unicode `\&#160;`.

NOTE: La etiqueta viewAction es nueva en JSF 2.2. Asocia un evento a una página y su uso es más flexible que el de la etiqueta event para acciones de precarga de datos de pantalla. En nuestra pantalla inicial el uso no sigue el patrón habitual. Un uso más adecuado se verá en la implementación de las pantallas de mantenimiento de trabajos.

Muy bien, una vez que tenemos correctamente actualizado el entorno de trabajo comenzamos con la implementación del caso de uso planteado. Como siempre habrá que implementar las capas de presentación y negocio. Empecemos por la primera.

Antes de empezar con la primera pantalla hay que crear una plantilla que proporcione el maquetado de las pantallas de la aplicación. Primefaces nos da la solución con Grid CSS, una librería de estilos con el que crear un layout responsive al estilo de Bootstrap. Antes de empezar con la implementación dibujamos un boceto del layout para tener claro los divs que tengo que considerar.

La plantilla debe ser privada, por tanto va situada dentro de la carpeta _WEB-INF_. Una plantilla contendrá en la cabecera elementos comunes a todas las páginas como gestión de la caché de cliente, estilos CSS comunes, y en el cuerpo el maquetado de la página y dentro de cada elemento div (con estilos de Grid CSS) las etiquetas <ui:insert...> de Facelets para insertar el contenido.

Una vez que tenemos lista nuestra plantilla, en la carpeta _/jdrone/src/main/webapp/WEB-INF/plantillas/plantilla.xhtml_, y su hoja de estilos correspondiente, podemos empezar a implementar cada pantalla de la aplicación en base a la plantilla.

La estructura de una página que usa una plantilla es la siguiente:

[source,xhtml,indent=0]
----
	<ui:composition...>
    	<ui:define name="central">
        	...
        </ui:define>
        <ui:define name="logo">
       		<ui:include... />
        </ui:define>
        ...
    </ui:composition>
----

El contenido de la zona variable, etiquetada con el nombre _central_ en la plantilla, se define en la página en general al principio, para mayor claridad, dado que aquí el orden no afecta. Como la zona del logo será fija para todas las pantallas la implementamos en un panel (una página xhtml privada) aparte y la añadimos con un include que toma como el panel.

En primer lugar vamos a adaptar nuestra pantalla de consulta de los posts anteriores, de drones disponibles en una fecha, al uso de la plantilla, y movemos el contenido desde el fichero index.xhtml, que ahora se convertirá en la pantalla inicial, al fichero consulta-inicial.xhtml.

En este punto vamos a añadir la librería jQuery y para hacer algo con ella como toma de contacto implementamos una simple animación del logo. Añadimos la librería al proyecto eligiendo la versión no comprimida para poder inspeccionar el código que nos interese. Una aplicación real en producción tendrá todos los ficheros js minimizados para ahorrar ancho de banda.

Lo siguiente que necesitamos es un menú de opciones. Se opta por la clásica barra de menú. Como suele ocurrir cuando necesitamos algún elemento para la capa de presentación Primefaces nos da también en esta ocasión la solución con el componente MenuBar. Tened en cuenta que la versión 5.2, abierta a la comunidad y usada en nuestro programa, tiene casi 150 componentes, y grancantidad de características adicionales. Dibujamos las opciones y submenús que tengamos previstos para la aplicación e implementamos el manú en un nuevo panel, de la misma manera que en el caso del logo.

Arrancamos el servidor y ejecutamos nuestro ciclo de construcción para ver cómo queda todo en pantalla. Personalmente no me convence el aspecto por defecto del menú por lo que acudimos de nuevo a Primefaces para cambiar de Theme. De paso activamos los iconos de FontAwesome añadiendo el correspondiente parámetro en el fichero _web.xml_ para tener una gama mayor de iconos para elegir.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig005.png[]

Para cambiar el Theme tenemos que añadir una dependencia de Maven, elegimos el Theme bluesky, más acorde con la Marca de la compañía:

[source,xml,indent=0]
----
  <dependency>
    <groupId>org.primefaces.themes</groupId>
    <artifactId>bluesky</artifactId>
    <version>1.0.10</version>
  </dependency>
----

Y añadir un parámetro en el descriptor de despliegue, web.xml:

[source,xml,indent=0]
----
  <context-param>
    <param-name>primefaces.THEME</param-name>
    <param-value>bluesky</param-value>
  </context-param>
----

Guardamos los cambios. Si abrimos el fichero pom.xml observamos que se muestra un error en la dependencia añadida, esto es debido a que esta dependencia no está en el repositorio Central. Tenemos por tanto que añadir el repositorio de Primefaces a nuestra configuración. Podemos hacerlo directamente desde la sugerencia que nos muestra Eclipse al poner el puntero del ratón sobre el error. Introducid los datos tal y como aparecen en la siguiente figura:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig010.png[]

Pulsamos OK y Finish. Para afinar el estilo de la barra de menú aún más podemos modificar el estilo aplicado por el frmaework a los componentes que forman el menú. En la documentación de Primefaces aparecen estos estilos pero lo más práctico es ayudarnos de las herramientas de desarrollador de Chrome o Firefox para localizar fácilmente los estilos aplicados a cada elemento sobre la propia pantalla y editarlos para ver los cambios _on the fly_.


Añadid al principio del fichero _plantilla.css_ lo siguiente: 

[source,css,indent=0]
----
.ui-menubar{
	height: 1.em;	
	padding:0em !important;	
}
.ui-menuitem{
	height: 1.8em;
}
----

Desplegad los cambios en WildFly y comprobad que el nuevo aspecto de la pantalla es similar a éste:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig015.png[]

NOTE: Existe una herramienta muy interesante que evita los redespliegues en el servidor de desarrollo durante la implementación de una aplicación. Se trata de JRebel, http://zeroturnaround.com/software/jrebel/. Es una herramienta de pago pero merece la pena bajar la versión demo y evaluar si nos merece la pena incluirla entre nuestro set de plugins.

Bien, para dejar lista la aplicación para el comienzo de la implementación de las dos pantallas de "Gestión de trabajos" movemos el contenido de index.html a consulta-inicial.xhtml y dejamos index.xhtml con un fondo de pantalla limpio como pantalla inicial de la aplicación, añadiendo una imagen de fondo.

Empezamos añadiendo la página que nos muestre la lista de trabajos. Tenemos que añadir a cada item un botón para eliminarlo, y otro para modificarlo. Además cada item tendrá un link para la consulta de los detalles del trabajo. Por último a nivel de página tendremos un botón para dar de alta un nuevo trabajo y otro para volver a la pantalla inicial.

Creamos la página trabajos.xhtml a partir de index.html. Escribiremos el código necesario dentro del define del área "central". A continuación creamos el backing bean para la página, TrabajosBean.java, en la misma carpeta que DisponibilidadBean.java y con el mismo ámbito. 

Lo siguiente es crear la clase de negocio. De momento iremos creando una para cada entidad persistente. Ya teníamos el bean de negocio de la entidad Drone, ahora creamos uno para la entidad Trabajo. Como para la entidad Trabajo necesitamos implementar las operaciones de persistencia típicas de un CRUD: Crear, Modificar, Eliminar y Consultar, vamos a refactorizar el código de los beans de negocio creando una superclase abstracta que contenga estas operaciones básicas, de manera que en la clase concreta sólo irán las operaciones de negocio particulares de cada una.

Creamos por tanto una nueva clase java con el nombre AbstractFacade.java en la carpeta _negocio_. Esta clase no necesita características de bean EJB por lo que no añadiremos ninguna anotación.

REFACTORIZAR BEANS EJB
EXPLICAR CLASE ABSTRACTA
EXPLICAR BEAN TRABAJOS
SEGUIR IMPLEMENTANDO PANTALLA DE LISTADO










