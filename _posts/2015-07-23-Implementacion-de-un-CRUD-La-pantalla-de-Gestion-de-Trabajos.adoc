= Implementación de un CRUD: La pantalla de Gestión de Trabajos.
La metaweb
:hp-tags: JSF, JavaServer Faces, CRUD, EJB, Hibernate, backing bean, Git, GitHub
:published_at: 2015-07-23

En este post os resumo los aspectos más relevantes de la implementación del caso de uso de introducción de Trabajos de Drones creado a partir de la solicitud de dicha funcionalidad por parte de nuestro cliente imaginario, TAS. La release de la que se parte es la 1.0.1, y a la que llegaremos será la 1.1.x. Así que usad la primera para intertar implementar la pantalla por vuestra cuenta y la segunda para ver la impleme tación terminada.

Yo aquí os haré una serie de comentarios sobre la release 1.1.x, señalando los detalles de implementación interesantes. Pero primero una breve introducción sobré qué es un mantenimiento de una entidad del modelo de dominio. En inglés se conoce como CRUD: Create, Read/Retrieve, Update, Delete, y se refiere al conjunto de elementos de diseño y programa necesarios para implementar el típico mantenimiento de una entidad. El caso más sencillo se da cuando la entidad es una entidad "hoja" en nuestro diagrama de clases. Si la entidad tiene una o más relaciones con otras entidades tendremos, en ocasiones, que mantenerlas también en el CRUD. Recordemos nuestro sencillo diagrama de clases:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig045.png[]

¿Qué mantenimientos podríamos hacer aquí? Bueno, en este caso tienen sentido dos mantenimientos. El que vamos a implementar, de la entidad Trabajo, donde tendremos que mantener la relación desde Trabajo hacia Drone, que representa la selección del drone que va a llevar a cabo el trabajo, y la relación del trabajo con sus puntos de ruta, que representa la ruta que seguirá el drone en ese trabajo. Y por otro lado también cabe realizar un CRUD de la entidad Drone donde no cabe el mantenimiento de la relación desde Drone a Trabajo ya que cuando por ejemplo creamos un drone no tiene sentido en nuestro caso asignarle en el mismo caso o en otro diferente uno o más trabajos.

Centrándonos en el mantenimiento de la entidad Trabajo empecemos con su resolución. Por partes, hacemos primero un análisis, luego el diseño de la interfaz y por último vemos la implementación de cada capa.

La lista de requisitos extraida de la entrevista con el cliente es la siguiente:

.Lista de requisitos del mantenimiento de trabajos
[width="90%"]
|===
|[small]*Pantalla de listado de trabajos*
|[small]#Inicialmente se presentará un listado de trabajos en pantalla.#
|[small]#El listado se debe ordenar por todos sus campos y se presentará paginado.#
|[small]#Sobre el listado dispondremos de comandos para Editar, dar de baja y dar de baja definitiva un trabajo.#
|[small]#La baja definitiva debe ser confirmada.#
|[small]*Pantalla de mantenimiento de trabajo*
|[small]#Todos los campos se validarán presentando mensajes adecuados.#
|[small]#Se presentará un listado de los drones disponibles según la fecha del trabajo.#
|[small]#La ruta se importará desde un excel generado por la aplicación de gestión de mapas usada para la definición de rutas sobre mapa.#
|===

Posteriormente a la definición de los requisitos decidimos si usar o no una librería JSF específica que nos aporte capacidades adicionales en la capa de presentación. Nuestras pantallas usarán listados con capacidades de ordenación, paginación, etc. Además necesitamos acciones con confirmación. El coste de incluir la librería es muy bajo y finalmente optamos por incluir una en nuestro proyecto. Entre RichFaces y Primefaces elegimos la segunda por sus características en cuanto a número de componentes, curva de aprindizaje, documentación, comunidad y tendencia exponencial de incremento en el uso en nuevos proyectos.

NOTE: Si queréis comparar la popularidad de distintas tecnologías usad Google Trends. Tendréis que añadir los términos que identifiquen a cada tecnología. Y hay que cuidar que el término no recoja resultados no deseados. Por ejmeplo si queréis ver la tendencia del framework ionic para aplicaciones híbridas escribir "ionic framework" y no "ionic" a secas. La URL es https://www.google.es/trends[ésta]. 

Añadimos PrimeFaces al proyecto. Además, optamos por trabajar con la última versión de JSF. La versión que trae EAP 6.3 es la 2.1. Se ha intentado seguir el procedimiento existente en la web para incluir la última versión en este servidor pero no ha sido posible. En resumen el proceso pasa por bajar una aplicación Maven desde Github que genera un fichero CLI que realiza el deploy de los tres slots para los tres módulos que se ven afectados por la actualización. Sin embargo uno de los slots da problemas ya que parece que el script está actualizado para operar con las versiones iniciales del servidor Wildfly y no del EAP.

De modo que optamos por adoptar el nuevo servidor Wildfly en su última versión, la 9.0.1, y así tener disponible una plataforma Java EE 7 completa. Lo primero será descargar el fichero de instlación del servidor http://wildfly.org/downloads/[aquí]. Tenéis que elegir la primera de las opciones, la que tiene la versión 9.0.1.Final.

NOTE: Descargaos también los Quickstarts porque os van a venir muy bien como material de consulta en las etapas iniciales de la implementanción de un nuevo proyecto sea cual sea la naturaleza de éste.

Una vez instalado WildFly lo añadimos a Eclipse como nueva unidad de ejecución. La versión de las JBoss Tools sólo ofrecía un conector para la versión 8 del servidor pero después de las pruebas de arranque y parada parece que para un uso sencillo no tendremos problemas con esto.

NOTE: Si no lo habéis hecho aún versionad bajo Git el proyecto y cread el correspondiente repositorio remoto en GitHub para ir publicando vuestras releases. 

¿Qué cambios tendremos que hacer en nuestro proyecto tras el cambio de servidor y la actualización de las versiones de las tecnologías? En primer lugar tendremos que adaptar las dependencias Maven a las del nuevo servidor, un proceso sin demasiada complicación. Para consultar los cambios en el código que se produzcan durante el desarrollo de este post  bajaos la release 1.1.x en https://github.com/lametaweb/jdrone/archive/1.1.0.zip[esta dirección].

Aprovechando que pom.xml ha variado he refactorizado el ciclo de construcción de modo que ahora existe un profile "despliegue-recursos" que se debe ejecutar la primera vez que despleguemos la aplicación o bien si los recursos has sido eliminados por cualquier motivo. Esto lo he hecho para evitar los problemas derivados del bloqueo de la base de datos. Tenéis que crear un nueva configuración de ejecución: Botón derecho proyecto > Rus As > Run Configurations... > botón derecho sobre Maven build > New > En la entrada Goals escribir "clean install -Pdespliegue-recursos" y dar un nombre al nuevo perfil.

En segundo lugar, como vamos a subir desde JSF 2.1 a 2.2 actualizamos los espacios de nombres en el nodo raiz del fichero _faces-config.xml_. Además tendremos que actualizar la faceta JavaServer Faces. La desmarcamos, esperamos a que se desinstale y la volvemos a marcar. Al añadirla de nuevo la opción _JSF Implementation Library_ dejadla así _Type > Disable Library Configuration_.

Para comprobar que JSF 2.2 funciona correctamente modificamos nuestra página index.xhtml para adaptarla a HTML5 y JSF 2.2, añadiendo además una etiqueta nueva en la versión 2.2.

Para la adaptación a HTML 5:

`<!DOCTYPE html>`

Para la adaptación a JSF 2.2 cambiamos los espacios de nombres:

`<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:h="http://xmlns.jcp.org/jsf/html"
	xmlns:f="http://xmlns.jcp.org/jsf/core">`

Finalmente sustituimos:

`<f:event listener="#{disponibilidadBean.listaEstadoDronesPorFecha()}" type="preRenderView" />`

por:

`<f:viewAction action="#{disponibilidadBean.listaEstadoDronesPorFecha()}" onPostback="true"></f:viewAction>`

Además ahora no se admitirán los típicos caracteres de espaciado `\&nbsp;` y tendremos que sustituirlos por el equivalente código unicode `\&#160;`.

NOTE: La etiqueta viewAction es nueva en JSF 2.2. Asocia un evento a una página y su uso es más flexible que el de la etiqueta event para acciones de precarga de datos de pantalla. En nuestra pantalla inicial el uso no sigue el patrón habitual. Un uso más adecuado se verá en la implementación de las pantallas de mantenimiento de trabajos.

Muy bien, una vez que tenemos correctamente actualizado el entorno de trabajo comenzamos con la implementación del caso de uso planteado. Como siempre habrá que implementar las capas de presentación y negocio. Empecemos por la primera.

Antes de empezar con la primera pantalla hay que crear una plantilla que proporcione el maquetado de las pantallas de la aplicación. Primefaces nos da la solución con Grid CSS, una librería de estilos con la que crearemos un layout responsive al estilo de Bootstrap. Antes de empezar con la implementación dibujamos un boceto del layout para tener claro los divs que tengo que considerar.

La plantilla debe ser privada, por tanto va situada dentro de la carpeta _WEB-INF_. Una plantilla contendrá en la cabecera elementos comunes a todas las páginas como gestión de la caché de cliente, estilos CSS comunes, y en el cuerpo el maquetado de la página y dentro de cada elemento div (con estilos de Grid CSS) las etiquetas <ui:insert...> de Facelets para insertar el contenido.

Una vez que tenemos lista nuestra plantilla, en la carpeta _/jdrone/src/main/webapp/WEB-INF/plantillas/plantilla.xhtml_, y su hoja de estilos correspondiente, podemos empezar a implementar cada pantalla de la aplicación en base a la plantilla.

La estructura de una página será:

[source,xhtml,indent=0]
----
	<ui:composition...>
    	<ui:define name="central">
        	...
        </ui:define>
        <ui:define name="logo">
       		<ui:include... />
        </ui:define>
        ...
    </ui:composition>
----

El contenido de la zona variable, etiquetada con el nombre _central_ en la plantilla, se define en la página en general al principio, para mayor claridad, dado que aquí el orden no afecta. Como la zona del logo será fija para todas las pantallas la implementamos en un panel (una página xhtml privada) aparte y la añadimos con un include que toma como el panel.

En primer lugar vamos a adaptar nuestra pantalla de consulta de los posts anteriores, de drones disponibles en una fecha, al uso de la plantilla, y movemos el contenido desde el fichero index.xhtml, que ahora se convertirá en la pantalla inicial, al fichero consulta-inicial.xhtml.

Implementamos el panel del logo e incluímos una simple animación en jQuery. Primefaces está basado en esta librería Javascript que es conveniente conocer ya que su uso está muy extendido en la capa de presentación de proyectos reales. Como nuestro proyecto incluye Primemefaces y éste incluye jQuery no tenemos que añadir la librería de manera explícita. En general, para cualquier proyecto, en páginas que no usen ninguna estiqueta de Primefaces incluiremos de manera explícita la librería jQuery embebida en Primefaces con las siguientes líneas:

`<h:outputScript library="primefaces" name="jquery/jquery.js" target="head" />`
`<h:outputScript library="primefaces" name="jquery/jquery-plugins.js" target="head" />`

Lo siguiente que necesitamos es un menú de opciones. Se opta por la clásica barra de menú. Como suele ocurrir cuando necesitamos algún elemento para la capa de presentación Primefaces nos da también en esta ocasión la solución con el componente MenuBar. Tened en cuenta que la versión 5.2, abierta a la comunidad y usada en nuestro programa, tiene casi 150 componentes, y grancantidad de características adicionales. Dibujamos las opciones y submenús que tengamos previstos para la aplicación e implementamos el manú en un nuevo panel, de la misma manera que en el caso del logo.

Arrancamos el servidor y ejecutamos nuestro ciclo de construcción para ver cómo queda todo en pantalla. Personalmente no me convence el aspecto por defecto del menú por lo que acudimos de nuevo a Primefaces para cambiar de Theme. De paso activamos los iconos de FontAwesome añadiendo el correspondiente parámetro en el fichero _web.xml_ para tener una gama mayor de iconos para elegir.

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig005.png[]

Para cambiar el Theme tenemos que añadir una dependencia de Maven, elegimos el Theme bluesky, más acorde con la Marca de la compañía:

[source,xml,indent=0]
----
  <dependency>
    <groupId>org.primefaces.themes</groupId>
    <artifactId>bluesky</artifactId>
    <version>1.0.10</version>
  </dependency>
----

Y añadir un parámetro en el descriptor de despliegue, web.xml:

[source,xml,indent=0]
----
  <context-param>
    <param-name>primefaces.THEME</param-name>
    <param-value>bluesky</param-value>
  </context-param>
----

Guardamos los cambios. Si abrimos el fichero pom.xml observamos que se muestra un error en la dependencia añadida, esto es debido a que esta dependencia no está en el repositorio Central. Tenemos por tanto que añadir el repositorio de Primefaces a nuestra configuración. Podemos hacerlo directamente desde la sugerencia que nos muestra Eclipse al poner el puntero del ratón sobre el error. Introducid los datos tal y como aparecen en la siguiente figura:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig010.png[]

Pulsamos OK y Finish. Para afinar el estilo de la barra de menú aún más podemos modificar el estilo aplicado por el frmaework a los componentes que forman el menú. En la documentación de Primefaces aparecen estos estilos pero lo más práctico es ayudarnos de las herramientas de desarrollador de Chrome o Firefox para localizar fácilmente los estilos aplicados a cada elemento sobre la propia pantalla y editarlos para ver los cambios _on the fly_.


Añadid al principio del fichero _plantilla.css_ lo siguiente: 

[source,css,indent=0]
----
.ui-menubar{
	height: 1.em;	
	padding:0em !important;	
}
.ui-menuitem{
	height: 1.8em;
}
----

Desplegad los cambios en WildFly y comprobad que el nuevo aspecto de la pantalla es similar a éste:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/009/post009-fig015.png[]

NOTE: Existe una herramienta muy interesante que evita los redespliegues en el servidor de desarrollo durante la implementación de una aplicación. Se trata de JRebel, http://zeroturnaround.com/software/jrebel/. Es una herramienta de pago pero merece la pena bajar la versión demo y evaluar si nos merece la pena incluirla entre nuestro set de plugins.

Bien, para dejar lista la aplicación para el comienzo de la implementación de las dos pantallas de "Gestión de trabajos" movemos el contenido de index.html a consulta-inicial.xhtml y dejamos index.xhtml con un fondo de pantalla limpio como pantalla inicial de la aplicación, añadiendo una imagen de fondo.

Empezamos añadiendo la página que nos muestre la lista de trabajos. Tenemos que añadir a cada item un botón para eliminarlo, y otro para modificarlo. Además cada item tendrá un link para la consulta de los detalles del trabajo. Por último a nivel de página tendremos un botón para dar de alta un nuevo trabajo y otro para volver a la pantalla inicial.

Creamos la página trabajos.xhtml a partir de index.html. Escribiremos el código necesario dentro del define del área "central". A continuación creamos el backing bean para la página, TrabajosBean.java, en la misma carpeta que DisponibilidadBean.java. 

El ámbito para el backing bean debe extenderse hasta el ámbito de la vista, ViewScoped. Esto es necesario porque en esta página vamos a implementar acciones que llaman a métodos con parámetros y para que esta construcción en EL (Expression Language) sea posible el bean debe permanecer en memoria más allá del ámbito de la petición.

NOTE: Tened cuidado de elegir la clase ViewScoped correcta tras pulsar Ctrl + O. Tenemos que elegir javax.faces.view.ViewScoped y no javax.faces.bean.ViewScoped. La segunda clase es nueva en JSF 2.2 y totalmente compatible con CDI.

Lo siguiente es crear la clase de negocio. De momento iremos creando una para cada entidad persistente. Ya teníamos el bean de negocio de la entidad Drone, ahora creamos uno para la entidad Trabajo. Como para la entidad Trabajo necesitamos implementar las operaciones de persistencia típicas de un CRUD: Crear, Modificar, Eliminar y Consultar, vamos a refactorizar el código de los beans de negocio creando una superclase abstracta que contenga estas operaciones básicas, de manera que en la clase concreta sólo irán las operaciones de negocio particulares de cada una.

Creamos por tanto una nueva clase java con el nombre AbstractFacade.java en la carpeta _negocio_. Esta clase no necesita características de bean EJB por lo que no añadiremos ninguna anotación. Y refactorizamos.

La clase TrabajoFacade inicialmente:

[source,java,indent=0]
----
package com.lametaweb.jdrone.negocio;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;

/**
 * Session Bean implementation class TrabajoFacade
 */
@Stateless
@LocalBean
public class TrabajoFacade {

    /**
     * Default constructor. 
     */
    public TrabajoFacade() {
        // TODO Auto-generated constructor stub
    }

}
----

La clase TrabajoFacade refactorizada:

[source,java,indent=0]
----
package com.lametaweb.jdrone.negocio;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import com.lametaweb.jdrone.persistencia.Trabajo;

/**
 * Session Bean implementation class TrabajoFacade
 */
@Stateless
@LocalBean
public class TrabajoFacade extends AbstractFacade<Trabajo>{
	
	@PersistenceContext(unitName = "datosdrones")
    private EntityManager em;

    /**
     * Default constructor. 
     */
    public TrabajoFacade() {
        // TODO Auto-generated constructor stub
    	super(Trabajo.class);
    }
    
    protected EntityManager getEntityManager(){
    	return em;
    }

}
----

Observad como la clase abstracta además es genérica dado que utiliza el método de consulta tipado y necesita referirse al tipo de la entidad que se gestiona en la subclase.

En primer lugar planteamos los métodos de negocio/dao que necesitamos, en este caso no necesito crear ninguno ya que en la superclase ya dispongo de un método que lee todos los trabajos y otro que lee un trabajo por su ID. A continuación iremos creando los componentes en la página xhtml y en paralelo los elementos java que vayamos necesitando en la clase backing bean. Continuaremos dentro de un proceso iterativo hasta conseguir una página de listado de trabajos libre de bugs. Es el momento de pasar a la página de detalle de trabajo que nos va a servir para consulta y modificación y para la que seguiremos el mismo proceso de implementación.

Empezamos con la página trabajos.xhtml, que iremos implementando y probando paso a paso. Implementad de forma metódica y no mezclando funcionalidades. El primer paso será simplemente mostrar la lista de trabajos en la pantalla. Aquí os copio el estado de la página y del backing bean con este primer paso implementado.

La página:

[source,xhtml,indent=0]
----
<ui:composition xmlns:ui="http://xmlns.jcp.org/jsf/facelets"
                xmlns:h="http://xmlns.jcp.org/jsf/html"                
                template="/WEB-INF/plantillas/plantilla.xhtml"
                xmlns:p="http://primefaces.org/ui"
                xmlns="http://www.w3.org/1999/xhtml"
                xmlns:f="http://xmlns.jcp.org/jsf/core">
	
	<f:metadata>
		<f:viewAction action="#{trabajosBean.actualizaModeloTrabajos()}"></f:viewAction>
	</f:metadata>
    <ui:define name="central">
		<!-- listado selección trabajos -->
		<h:form>

		<p:dataTable var="trabajo" value="#{trabajosBean.trabajos}">
		    <p:column headerText="N. Registro">
		        <h:outputText value="#{trabajo.numeroDeRegistro}" />
		    </p:column>
		 
		    <p:column headerText="Inicio" priority="3">
		        <h:outputText value="#{trabajo.fechaHoraInicio}" />
		    </p:column>
		 
		    <p:column headerText="Finalización" priority="2">
		        <h:outputText value="#{trabajo.fechaHoraFinalizacion}" />
		    </p:column>
		 
		    <p:column headerText="Drone" priority="4">
		        <h:outputText value="#{trabajo.droneAsignado.numeroDeSerie}" />
		    </p:column>
		</p:dataTable>
		</h:form>
	</ui:define>
	
	<!-- contenido de zona logo -->
    <ui:define name="logo">
        <ui:include src="/WEB-INF/paneles/panelLogo.xhtml" />
    </ui:define>

	<!-- contenido de zona barra menu -->
    <ui:define name="menu">
        <ui:include src="/WEB-INF/paneles/panelMenu.xhtml" />
    </ui:define>
    
	<!-- TODO: contenido de otras zonas... -->

</ui:composition>
----

Y la clase:

[source,java,indent=0]
----
package com.lametaweb.jdrone.vista;

import java.util.List;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.inject.Named;

import com.lametaweb.jdrone.negocio.TrabajoFacade;
import com.lametaweb.jdrone.persistencia.Trabajo;

@Named
@RequestScoped
public class TrabajosBean {
	
	private List<Trabajo> trabajos;
	@Inject
	private TrabajoFacade trabajoFacade;

	public TrabajosBean() {
		// TODO Auto-generated constructor stub
	}

	
	public void actualizaModeloTrabajos(){
		trabajos = trabajoFacade.findAll();
	}
	
	
	public List<Trabajo> getTrabajos() {
		return trabajos;
	}
}
----

Añadimos a continuación los botones de eliminación y edición a la tabla. La eliminación la hacemos con una llamada ajax, que es el comportamiento por defecto en PrimeFaces, para que sólo se actualice la tabla. Después de comprobar que puedo eliminar un trabajo correctamente paso a implementar el cuadro de diálogo de confirmación. En un borrado ya sea físico o lógico siempre poned antes una confirmación. La manera más limpia de añadir un cuadro de confirmación es con un ConfirmDialog global.

Cuando implementamos operaciones de negocio con Hibernate ayuda bastante, durante la depuración del código, visualizar las sentencias SQL que Hibernate genera contra la base de datos, de modo que podamos detectar problemas con facilidad. Una primera aproximación a esto es añadir esta configuración a Hibernate en el archivo _persistence.xml_:

[source,xml,indent=0]
----
  <property name="hibernate.show_sql" value="true"/>
  <property name="hibernate.format_sql" value="true"/>
----

Pero esto sólo nos sacará por la consola las sentencias SQL, sin los valores de los parámetros. Para mostrar estos valores tenemos que ajustar la configuración de  log4j añadiendo el fichero log4j.properties en alguna carpeta del classpath y estableciendo las propiedades necesarias. Cuando necesitemos visualizar la consulta real lanzada por Hibernate contra la base de datos utilizaremos un driver de proxy jdbc como https://p6spy.github.io/p6spy/2.0/install.html#generic[P6Spy].










VER PRUEBAS CON ARQUILLIAN
https://github.com/wildfly/boms/tree/master/jboss-javaee-7.0-with-tools








