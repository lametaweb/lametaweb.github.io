= Implementación de pantalla de introducción de Trabajos (CRUD).
La metaweb
:hp-tags: JSF, JavaServer Faces, CRUD, EJB, Hibernate, backing bean, Git, GitHub
:published_at: 2015-07-23

En este post os resumo los aspectos más relevantes de la implementación del caso de uso de introducción de Trabajos de Drones creado a partir de la solicitud de dicha funcionalidad por parte de nuestro cliente imaginario, TAS. La release de la que se parte es la 1.0.1, y a la que llegaremos será la 1.1.x. Así que usad la primera para intertar implementar la pantalla por vuestra cuenta y la segunda para ver la impleme tación terminada.

Yo aquí os haré una serie de comentarios sobre la release 1.1.x, señalando los detalles de implementación interesantes. Pero primero una breve introducción sobré qué es un mantenimiento de una entidad del modelo de dominio. En inglés se conoce como CRUD: Create, Read/Retrieve, Update, Delete, y se refiere al conjunto de elementos de diseño y programa necesarios para implementar el típico mantenimiento de una entidad. El caso más sencillo se da cuando la entidad es una entidad "hoja" en nuestro diagrama de clases. Si la entidad tiene una o más relaciones con otras entidades tendremos, en ocasiones, que mantenerlas también en el CRUD. Recordemos nuestro sencillo diagrama de clases:

image::https://raw.githubusercontent.com/lametaweb/lametaweb.github.io/master/images/003/post003-fig045.png[]

¿Qué mantenimientos podríamos hacer aquí? Bueno, en este caso tienen sentido dos mantenimientos. El que vamos a implementar, de la entidad Trabajo, donde tendremos que mantener la relación desde Trabajo hacia Drone, que representa la selección del drone que va a llevar a cabo el trabajo, y la relación del trabajo con sus puntos de ruta, que representa la ruta que seguirá el drone en ese trabajo. Y por otro lado también cabe realizar un CRUD de la entidad Drone donde no cabe el mantenimiento de la relación desde Drone a Trabajo ya que cuando por ejemplo creamos un drone no tiene sentido en nuestro caso asignarle en el mismo caso o en otro diferente uno o más trabajos.

Centrándonos en el mantenimiento de la entidad Trabajo empecemos con su resolución. Por partes, hacemos primero un análisis, luego el diseño de la interfaz y por último vemos la implementación de cada capa.

La lista de requisitos extraida de la entrevista con el cliente es la siguiente:

.Lista de requisitos del mantenimiento de trabajos
[width="90%"]
|===
|[small]*Pantalla de listado de trabajos*
|[small]#Inicialmente se presentará un listado de trabajos en pantalla.#
|[small]#El listado se debe ordenar por todos sus campos y se presentará paginado.#
|[small]#Sobre el listado dispondremos de comandos para Editar, dar de baja y dar de baja definitiva un trabajo.#
|[small]#La baja definitiva debe ser confirmada.#
|[small]*Pantalla de mantenimiento de trabajo*
|[small]#Todos los campos se validarán presentando mensajes adecuados.#
|[small]#Se presentará un listado de los drones disponibles según la fecha del trabajo.#
|[small]#La ruta se importará desde un excel generado por la aplicación de gestión de mapas usada para la definición de rutas sobre mapa.#
|===

Posteriormente a la definición de los requisitos decidimos si usar o no una librería JSF específica que nos aporte capacidades adicionales en la capa de presentación. Nuestras pantallas usarán listados con capacidades de ordenación, paginación, etc. Además necesitamos acciones con confirmación. El coste de incluir la librería es muy bajo y finalmente optamos por incluir una en nuestro proyecto. Entre RichFaces y Primefaces elegimos la segunda por sus características en cuanto a número de componentes, curva de aprindizaje, documentación, comunidad y tendencia exponencial de incremento en el uso en nuevos proyectos.

NOTE: Si queréis comparar la popularidad de distintas tecnologías usad Google Trends. Tendréis que añadir los términos que identifiquen a cada tecnología. Y hay que cuidar que el término no recoja resultados no deseados. Por ejmeplo si queréis ver la tendencia del framework ionic para aplicaciones híbridas escribir "ionic framework" y no "ionic" a secas. La URL es https://www.google.es/trends[ésta]. 

Añadimos PrimeFaces al proyecto. Además, optamos por trabajar con la última versión de JSF. La versión que trae EAP 6.3 es la 2.1. Se ha intentado seguir el procedimiento existente en la web para incluir la última versión en este servidor pero no ha sido posible. En resumen el proceso pasa por bajar una aplicación Maven desde Github que genera un fichero CLI que realiza el deploy de los tres slots para los tres módulos que se ven afectados por la actualización. Sin embargo uno de los slots da problemas ya que parece que el script está actualizado para operar con las primeras versiones del servidor Wildfly.

De modo que se opta por instalar el nuevo servidor Wildfly en su última versión, la 9.0.1, y así tener disponible una plataforma Java EE 7 completa. Lo primero será descargar el fichero de instlación del servidor http://wildfly.org/downloads/[aquí]. Tenéis que elegir la primera de las opciones, la que tiene la versión 9.0.1.Final.

NOTE: Descargaos también los Quickstarts porque os van a venir muy bien como material de consulta en las etapas iniciales de la implementanción de un nuevo proyecto sea cual sea la naturaleza de éste.

Una vez instalado WildFly lo añadimos a Eclipse como nueva unidad de ejecución. La versión de las JBoss Tools sólo ofrecía un conector para la versión 8 del servidor pero después de las pruebas de arranque y parada parece que para un uso sencillo no tendremos problemas con esto.

¿Qué cambios tendremos que hacer en nuestro proyecto tras el cambio de servidor y la actualización de las versiones de las tecnologías? En primer lugar tendremos que adaptar las dependencias Maven a las del nuevo servidor, un proceso sin demasiada complicación. Para consultar los cambios en el código que se produzcan durante el desarrollo de este post  bajaos la release 1.1.x en https://github.com/lametaweb/jdrone/archive/1.1.0.zip[esta dirección].

En segundo lugar, como vamos a subir desde JSF 2.1 a 2.2 actualizamos los espacios de nombres en el nodo raiz del fichero _faces-config.xml_. Además tendremos que actualizar la faceta JavaServer Faces. La desmarcamos, esperamos a que se desinstale y la volvemos a marcar. Al añadirla de nuevo la opción _JSF Implementation Library_ dejadla así _Type > Disable Library Configuration_.

Para comprobar que JSF 2.2 funciona correctamente modificamos nuestra página index.xhtml para adaptarla a HTML5 y JSF 2.2, añadiendo además una etiqueta nueva en la versión 2.2.

Para la adaptación a HTML 5:

`<!DOCTYPE html>`

Para la adaptación a JSF 2.2 cambiamos los espacios de nombres:

`<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:h="http://xmlns.jcp.org/jsf/html"
	xmlns:f="http://xmlns.jcp.org/jsf/core">`

Finalmente sustituimos:

`<f:event listener="#{disponibilidadBean.listaEstadoDronesPorFecha()}" type="preRenderView" />`

por:

`<f:viewAction action="#{disponibilidadBean.listaEstadoDronesPorFecha()}" onPostback="true"></f:viewAction>`

Además ahora no se admitirán los típicos caracteres de espaciado `\&nbsp;` y tendremos que sustituirlos por el equivalente código unicode `\&#160;`.

NOTE: La etiqueta viewAction es nueva en JSF 2.2. Asocia un evento a una página y su uso es más flexible que el de la etiqueta event para acciones de precarga de datos de pantalla. En nuestra pantalla inicial el uso no sigue el patrón habitual. Un uso más adecuado se verá en la implementación de las pantallas de mantenimiento de trabajos.

Muy bien, una vez que tenemos correctamente actualizado el entorno de trabajo y disponemos de los requisitos para las pantallas de mantenimiento de trabajos pasaríamos al diseño de las mismas. Podemos usar lápiz y papel o algún programa de dibujo. Sobre estos diseños vemos si existen zonas comunes a las dos pantallas y si es así añadimos una plantilla aprovechando las capacidades que nos brinda JSF con Facelets. Optamos por añadir una plantilla simple.

HACER COMMITS Y CREAR PLANTILLA





